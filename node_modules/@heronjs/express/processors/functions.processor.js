"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionsProcessor = void 0;
const errors_1 = require("@heronjs/common/errors");
const common_1 = require("@heronjs/common");
const rxjs_1 = require("rxjs");
const consts_1 = require("@heronjs/common/consts");
const abstract_processor_1 = require("./abstract.processor");
class FunctionsProcessor extends abstract_processor_1.AbstractProcessor {
    constructor() {
        super(...arguments);
        this.apply = (thisArgs, metas, res, req) => {
            if (!thisArgs)
                throw new errors_1.FunctionError(`can not dispatch function with ${thisArgs}`);
            return function (func, args) {
                if ((0, common_1.isFunction)(func)) {
                    try {
                        const { type } = metas;
                        switch (type) {
                            case common_1.FunctionType.prom:
                                return (0, rxjs_1.defer)(() => func.apply(thisArgs, args));
                            case common_1.FunctionType.obs:
                                return func.apply(thisArgs, args);
                            case common_1.FunctionType.func:
                            default:
                                return func.apply(thisArgs, args);
                        }
                    }
                    catch (e) {
                        (0, consts_1.rethrow)(e);
                    }
                }
                throw new errors_1.FunctionError(`can not dispatch non function ${func}`);
            };
        };
        this.dispatch = (thisArgs) => {
            if (!thisArgs)
                throw new errors_1.FunctionError(`can not dispatch function with ${thisArgs}`);
            return function (func, args) {
                if ((0, common_1.isFunction)(func)) {
                    try {
                        return (0, rxjs_1.defer)(() => func.apply(thisArgs, args)).subscribe();
                    }
                    catch (e) {
                        (0, consts_1.rethrow)(e);
                    }
                }
                throw new errors_1.FunctionError(`can not dispatch non function ${func}`);
            };
        };
        this.dispatchWithUri = (thisArgs) => {
            if (!thisArgs)
                throw new errors_1.FunctionError(`can not dispatch function with ${thisArgs}`);
            return (func, request, args, cache) => {
                if ((0, common_1.isFunction)(func)) {
                    try {
                        return (0, rxjs_1.defer)(() => func.apply(thisArgs, args)).subscribe();
                    }
                    catch (e) {
                        (0, consts_1.rethrow)(e);
                    }
                }
                throw new errors_1.FunctionError(`can not dispatch non function ${func}`);
            };
        };
    }
}
exports.FunctionsProcessor = FunctionsProcessor;
