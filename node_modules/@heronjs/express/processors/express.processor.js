"use strict";
var _ExpressProcessor_logger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressProcessor = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("@heronjs/common/errors");
const common_1 = require("@heronjs/common");
const rxjs_1 = require("rxjs");
const http_status_codes_1 = require("http-status-codes");
const messages_consts_1 = require("@heronjs/common/consts/messages.consts");
const abstract_processor_1 = require("./abstract.processor");
class ExpressProcessor extends abstract_processor_1.AbstractProcessor {
    constructor() {
        super();
        _ExpressProcessor_logger.set(this, new common_1.Logger(ExpressProcessor.name));
        this.render = (thisArg, view) => {
            if (!thisArg || !view)
                throw new errors_1.FunctionError((0, messages_consts_1.CAN_NOT_DISPATCH_FUNCTION)(`${thisArg} | ${view}`));
            const { response } = view;
            const rendering = (page, data, layout) => {
                return response && response.render(page, Object.assign({ layout: layout ? layout : false }, data));
            };
            const renderError = (error) => {
                return response && response.status(http_status_codes_1.StatusCodes.BAD_REQUEST).send((0, messages_consts_1.RENDER_ERROR_IN_HTML)(error));
            };
            return (fn, args) => {
                const { type, layout } = view;
                if (type && (fn && (0, common_1.isFunction)(fn))) {
                    switch (type) {
                        case common_1.FunctionType.prom:
                            return (0, rxjs_1.defer)(() => fn.apply(thisArg, args))
                                .subscribe({
                                next: (data) => rendering(data[0], data[1], layout),
                                error: (err) => renderError(err)
                            });
                        case common_1.FunctionType.obs:
                            return fn.apply(thisArg, args)
                                .subscribe({
                                next: (data) => rendering(data[0], data[1], layout),
                                error: (err) => renderError(err)
                            });
                        case common_1.FunctionType.func:
                        default:
                            try {
                                const data = fn.apply(thisArg, args);
                                return rendering(data[0], data[1], layout);
                            }
                            catch (e) {
                                renderError(e);
                            }
                    }
                }
            };
        };
        this.dispatch = (thisArg, route) => {
            if (!thisArg || !route)
                throw new errors_1.FunctionError((0, messages_consts_1.CAN_NOT_DISPATCH_FUNCTION)(`${thisArg} | ${route}`));
            const success = (data, res, code) => {
                return res.status(code || 200).send(common_1.HttpResponseUtils.output(data));
            };
            return (fn, args, cache) => {
                if ((0, common_1.isFunction)(fn)) {
                    const { type, headers, code, response, next, request } = route;
                    const _addHeaders = (headers) => {
                        if (headers) {
                            const keys = Object.keys(headers);
                            keys.forEach(key => {
                                const value = headers[key];
                                const needExecute = (0, common_1.isFunction)(value);
                                response && response.set(key, needExecute ? value() : value);
                            });
                        }
                    };
                    switch (type) {
                        case common_1.FunctionType.prom:
                        case common_1.FunctionType.obs:
                            const $processing = fn.apply(thisArg, args);
                            return (0, rxjs_1.defer)(() => $processing).pipe((0, rxjs_1.catchError)(err => (0, rxjs_1.throwError)(() => err)), (0, rxjs_1.tap)((result) => (request && cache) && this.$cacheIfAvailable(result, request, cache))).subscribe({
                                next: (data) => {
                                    _addHeaders(headers);
                                    return response && success(data, response, code);
                                },
                                error: (err) => next && next(err)
                            });
                        case common_1.FunctionType.func:
                        default:
                            try {
                                const result = fn.apply(thisArg, args);
                                _addHeaders(headers);
                                (request && cache) && this.$cacheIfAvailable(result, request, cache);
                                return response && success(result, response, code);
                            }
                            catch (e) {
                                next && next(e);
                            }
                    }
                }
                throw new errors_1.FunctionError((0, messages_consts_1.CAN_NOT_DISPATCH_FUNCTION)(`${fn}`));
            };
        };
        this.parameterize = (args) => (metas) => (req, res, ext) => {
            if (!metas)
                return [];
            metas.forEach(meta => {
                var _a, _b;
                const { type, reflect = '', index } = meta;
                let arg;
                const variable = (0, common_1.isSymbol)(reflect) ? reflect.toString() : reflect;
                switch (type) {
                    case common_1.HttpParameter.BODY:
                        arg = req.body;
                        break;
                    case common_1.HttpParameter.QUERY:
                        arg = req.query[variable];
                        break;
                    case common_1.HttpParameter.PARAM:
                        arg = req.params[variable];
                        break;
                    case common_1.HttpParameter.HEADER:
                        arg = req.headers[variable];
                        break;
                    case common_1.HttpParameter.REQUEST:
                        arg = req;
                        break;
                    case common_1.HttpParameter.RESPONSE:
                        arg = res;
                        break;
                    case common_1.HttpParameter.ORIGINAL_URL:
                        arg = req.originalUrl;
                        break;
                    case common_1.HttpParameter.URL:
                        arg = req.url;
                        break;
                    case common_1.HttpParameter.ARRAY_QUERY:
                        arg = req.query[variable];
                        if ((0, common_1.isString)(arg) && arg.includes(ExpressProcessor.COMMA_SYMBOL)) {
                            arg = arg.split(ExpressProcessor.COMMA_SYMBOL);
                        }
                        else
                            arg ? arg = [arg] : undefined;
                        break;
                    case common_1.HttpParameter.AUTHORIZE:
                        if (variable)
                            arg = (_a = res.locals) === null || _a === void 0 ? void 0 : _a.authContext[variable];
                        else
                            arg = (_b = res.locals) === null || _b === void 0 ? void 0 : _b.authContext;
                        break;
                    case common_1.HttpParameter.IP:
                        arg = req.ips || req.ip;
                        break;
                    case common_1.HttpParameter.QUERIES:
                        arg = req.query;
                        break;
                    case common_1.HttpParameter.FUSE:
                        try {
                            arg = this._di && this._di.__get({ token: variable });
                        }
                        catch (e) {
                            tslib_1.__classPrivateFieldGet(this, _ExpressProcessor_logger, "f").warning(`Looking for unbound property ${variable}!`);
                            arg = undefined;
                        }
                        break;
                    default:
                        return undefined;
                }
                args[index] = arg;
            });
            return args;
        };
        this.errorHandler = () => (err, req, res, next) => {
            if (err) {
                if (!common_1.PRODUCTION) {
                    tslib_1.__classPrivateFieldGet(this, _ExpressProcessor_logger, "f").trace(err.message, err);
                }
                if (err instanceof errors_1.APIError) {
                    const cin = (0, common_1.isString)(err.code) ? parseInt(err.code) : err.code;
                    return res.status(cin).send(common_1.HttpResponseUtils.error(err));
                }
                else if (err instanceof errors_1.RuntimeError) {
                    return res.status(http_status_codes_1.StatusCodes.INTERNAL_SERVER_ERROR).send(common_1.HttpResponseUtils.error(err));
                }
                else {
                    return res.status(http_status_codes_1.StatusCodes.INTERNAL_SERVER_ERROR).send({
                        stacktrace: err.stack
                    });
                }
            }
            return next();
        };
    }
}
exports.ExpressProcessor = ExpressProcessor;
_ExpressProcessor_logger = new WeakMap();
ExpressProcessor.COMMA_SYMBOL = ',';
