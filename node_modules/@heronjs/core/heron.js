"use strict";
var _HeronStatic_isAbort, _HeronStatic_rootApp, _HeronStatic_logger, _HeronStatic_server, _HeronStatic_wsServer, _HeronStatic_graphServer, _HeronStatic_container, _HeronStatic_di, _HeronStatic_initgvs, _HeronStatic_createProxyInstance, _HeronStatic_createContext, _HeronStatic_mixinDI, _HeronStatic_createConstVariables, _HeronStatic_loadConfigAndPlugin, _HeronStatic_activateExtensions, _HeronStatic_getGateKeeperIfExists, _HeronStatic_createDI, _HeronStatic_createProxy, _HeronStatic_createExceptionProxy, _HeronStatic_createErrorHandler, _HeronStatic_createApplicationProxy, _HeronStatic_root;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Heron = exports.HeronJS = exports.HeronStatic = void 0;
const tslib_1 = require("tslib");
const context_1 = require("./context");
const inversify_1 = require("inversify");
const common_1 = require("@heronjs/common");
const validators_1 = require("@heronjs/common/utils/validators");
const errors_1 = require("./errors");
const server_1 = require("./server");
const di_1 = require("./di");
const declarations_1 = require("@heronjs/common/declarations");
const utils_1 = require("./utils");
const extensions_1 = require("./extensions");
const consts_1 = require("./consts");
const messages_consts_1 = require("@heronjs/common/consts/messages.consts");
class HeronStatic {
    constructor() {
        _HeronStatic_isAbort.set(this, true);
        _HeronStatic_rootApp.set(this, void 0);
        _HeronStatic_logger.set(this, new common_1.Logger(HeronStatic.name));
        _HeronStatic_server.set(this, void 0);
        _HeronStatic_wsServer.set(this, void 0);
        _HeronStatic_graphServer.set(this, void 0);
        _HeronStatic_container.set(this, new inversify_1.Container({
            autoBindInjectable: true,
            skipBaseClassChecks: true,
            defaultScope: 'Singleton'
        }));
        _HeronStatic_di.set(this, void 0);
        _HeronStatic_initgvs.set(this, () => global.HeronJS = {
            routes: [],
            services: [],
            websocket: [],
            config: {}
        });
        _HeronStatic_createProxyInstance.set(this, async (instance) => tslib_1.__classPrivateFieldGet(this, _HeronStatic_createProxy, "f").call(this, instance));
        _HeronStatic_createContext.set(this, async (module, server, wsServer, graphServer) => {
            const context = new context_1.HeronContext(module, server, wsServer, graphServer);
            context && await context.bootstrap();
            return context;
        });
        _HeronStatic_mixinDI.set(this, async (target, refer) => {
            (0, common_1.__mixinIfAbsent)(target, { name: declarations_1.MODULE_DI, refers: () => refer });
            await tslib_1.__classPrivateFieldGet(this, _HeronStatic_createConstVariables, "f").call(this, refer, target);
        });
        _HeronStatic_createConstVariables.set(this, async (di, context) => {
            try {
                const _gatekeeper = (0, common_1.__obtain)(declarations_1.MODULE_GATEKEEPER, context);
                const _gateKeeperResolver = (0, common_1.__obtain)(declarations_1.SELF_RESOLVER, _gatekeeper);
                _gatekeeper && di.__constantValue({ token: common_1.SYSTEM_VARIABLES, value: _gatekeeper, named: common_1.GATEKEEPER });
                _gateKeeperResolver && di.__constantValue({
                    token: common_1.SYSTEM_VARIABLES,
                    value: _gateKeeperResolver,
                    named: common_1.GATEKEEPER_RESOLVER
                });
                tslib_1.__classPrivateFieldGet(this, _HeronStatic_initgvs, "f").call(this);
            }
            catch (error) {
                (error instanceof Error) && tslib_1.__classPrivateFieldGet(this, _HeronStatic_logger, "f").fatal(error.message, error);
                (0, common_1.__forceShutdownGracefully)();
            }
        });
        _HeronStatic_loadConfigAndPlugin.set(this, async (di) => {
            try {
                const config = await (0, utils_1._$loadConfig)();
                config && di?.__constantValue({ token: consts_1.SYSTEM_CONFIG, value: config });
                return config;
            }
            catch (error) {
                (error instanceof Error) && tslib_1.__classPrivateFieldGet(this, _HeronStatic_logger, "f").fatal(error.message, error);
                (0, common_1.__forceShutdownGracefully)();
            }
        });
        _HeronStatic_activateExtensions.set(this, async (config) => {
            const [gateKeeper, resolver] = await tslib_1.__classPrivateFieldGet(this, _HeronStatic_getGateKeeperIfExists, "f").call(this);
            const prerequisites = [];
            if (config && config.apm)
                prerequisites.push(consts_1.PERF_MODULE);
            if (config && config.extensions)
                prerequisites.push(...config.extensions);
            const props = { gateKeeper, resolver, config };
            tslib_1.__classPrivateFieldSet(this, _HeronStatic_server, await (0, extensions_1.activate)(consts_1.EXPRESS_MODULE, { ...props, shareholder: server_1.HttpServer }), "f");
            tslib_1.__classPrivateFieldSet(this, _HeronStatic_wsServer, await (0, extensions_1.activate)(consts_1.WEBSOCKET_MODULE, { ...props, shareholder: server_1.WebSocketServer }), "f");
            tslib_1.__classPrivateFieldSet(this, _HeronStatic_graphServer, await (0, extensions_1.activate)(consts_1.GRAPHQL_MODULE, { ...props, shareholder: server_1.GraphQLServer }), "f");
            (prerequisites && prerequisites.length > 0) && await (0, extensions_1.activates)(prerequisites, props);
            return [tslib_1.__classPrivateFieldGet(this, _HeronStatic_server, "f"), tslib_1.__classPrivateFieldGet(this, _HeronStatic_wsServer, "f"), tslib_1.__classPrivateFieldGet(this, _HeronStatic_graphServer, "f")];
        });
        _HeronStatic_getGateKeeperIfExists.set(this, async () => {
            try {
                const gateKeeper = tslib_1.__classPrivateFieldGet(this, _HeronStatic_di, "f")?.__get({ token: common_1.SYSTEM_VARIABLES, named: common_1.GATEKEEPER });
                const gateKeeperResolver = tslib_1.__classPrivateFieldGet(this, _HeronStatic_di, "f")?.__get({
                    token: common_1.SYSTEM_VARIABLES,
                    named: common_1.GATEKEEPER_RESOLVER
                });
                return [gateKeeper, gateKeeperResolver];
            }
            catch (error) {
                (0, common_1.rethrow)(error);
            }
        });
        _HeronStatic_createDI.set(this, async (container) => tslib_1.__classPrivateFieldSet(this, _HeronStatic_di, new di_1.ModuleDI(container), "f"));
        _HeronStatic_createProxy.set(this, (target) => {
            const proxy = tslib_1.__classPrivateFieldGet(this, _HeronStatic_createExceptionProxy, "f").call(this);
            return new Proxy(target, {
                get: proxy,
                set: proxy
            });
        });
        _HeronStatic_createExceptionProxy.set(this, () => {
            return (receiver, prop) => {
                if (!(prop in receiver)) {
                    return;
                }
                if ((0, validators_1.isFunction)(receiver[prop])) {
                    return tslib_1.__classPrivateFieldGet(this, _HeronStatic_createErrorHandler, "f").call(this, receiver, prop);
                }
                return receiver[prop];
            };
        });
        _HeronStatic_createErrorHandler.set(this, (receiver, prop) => {
            const teardown = !tslib_1.__classPrivateFieldGet(this, _HeronStatic_isAbort, "f") ? common_1.rethrow : undefined;
            return (...args) => {
                let result;
                new errors_1.ErrorHandler().accept(() => {
                    result = receiver[prop](...args);
                }, teardown);
                return result;
            };
        });
        _HeronStatic_createApplicationProxy.set(this, async (app, adapter) => {
            const proxy = new Proxy(app, {
                get: (receiver, prop) => {
                    const wrap = (result) => {
                        return result instanceof Promise
                            ? result.then(wrap)
                            : result instanceof context_1.HeronContext
                                ? proxy
                                : result;
                    };
                    if (!(prop in receiver) && (adapter && prop in adapter)) {
                        return (...args) => {
                            const result = tslib_1.__classPrivateFieldGet(this, _HeronStatic_createErrorHandler, "f").call(this, adapter, prop)(...args);
                            return wrap(result);
                        };
                    }
                    if ((0, validators_1.isFunction)(receiver[prop])) {
                        return (...args) => {
                            const result = receiver[prop](...args);
                            return wrap(result);
                        };
                    }
                    return receiver[prop];
                }
            });
            return tslib_1.__classPrivateFieldGet(this, _HeronStatic_root, "f").call(this, proxy);
        });
        _HeronStatic_root.set(this, async (proxy) => {
            return tslib_1.__classPrivateFieldSet(this, _HeronStatic_rootApp, (0, common_1.__mixinIfAbsent)(global, { name: declarations_1.MODULE_ROOT, refers: () => proxy })[0], "f");
        });
        global.__rootDir__ = __dirname || process.cwd();
    }
    async create(args) {
        const { module } = args;
        const di = await tslib_1.__classPrivateFieldGet(this, _HeronStatic_createDI, "f").call(this, tslib_1.__classPrivateFieldGet(this, _HeronStatic_container, "f"));
        if (di) {
            await tslib_1.__classPrivateFieldGet(this, _HeronStatic_mixinDI, "f").call(this, module, di);
            const configuration = await tslib_1.__classPrivateFieldGet(this, _HeronStatic_loadConfigAndPlugin, "f").call(this, di);
            const [server, wsServer, graphServer] = await tslib_1.__classPrivateFieldGet(this, _HeronStatic_activateExtensions, "f").call(this, configuration);
            if (!server)
                throw new common_1.ModuleError(common_1.SYSErrors.SERVER_ERR, (0, messages_consts_1.CAN_NOT_START_SERVER)('Failed to initialize http server!'));
            const context = await tslib_1.__classPrivateFieldGet(this, _HeronStatic_createContext, "f").call(this, module, server, wsServer, graphServer);
            const target = await tslib_1.__classPrivateFieldGet(this, _HeronStatic_createProxyInstance, "f").call(this, context);
            return tslib_1.__classPrivateFieldGet(this, _HeronStatic_createApplicationProxy, "f").call(this, target, server);
        }
        else
            throw new common_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.MODULE_INJECTOR_ERROR)(di));
    }
}
exports.HeronStatic = HeronStatic;
_HeronStatic_isAbort = new WeakMap(), _HeronStatic_rootApp = new WeakMap(), _HeronStatic_logger = new WeakMap(), _HeronStatic_server = new WeakMap(), _HeronStatic_wsServer = new WeakMap(), _HeronStatic_graphServer = new WeakMap(), _HeronStatic_container = new WeakMap(), _HeronStatic_di = new WeakMap(), _HeronStatic_initgvs = new WeakMap(), _HeronStatic_createProxyInstance = new WeakMap(), _HeronStatic_createContext = new WeakMap(), _HeronStatic_mixinDI = new WeakMap(), _HeronStatic_createConstVariables = new WeakMap(), _HeronStatic_loadConfigAndPlugin = new WeakMap(), _HeronStatic_activateExtensions = new WeakMap(), _HeronStatic_getGateKeeperIfExists = new WeakMap(), _HeronStatic_createDI = new WeakMap(), _HeronStatic_createProxy = new WeakMap(), _HeronStatic_createExceptionProxy = new WeakMap(), _HeronStatic_createErrorHandler = new WeakMap(), _HeronStatic_createApplicationProxy = new WeakMap(), _HeronStatic_root = new WeakMap();
const HeronJS = new HeronStatic();
exports.HeronJS = HeronJS;
const Heron = HeronJS;
exports.Heron = Heron;
