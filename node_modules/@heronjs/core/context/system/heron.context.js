"use strict";
var _HeronContext_logger, _HeronContext_isAbort, _HeronContext_stats, _HeronContext_initialize, _HeronContext_applyExtensionIfPossible, _HeronContext_abortOnInitializeError, _HeronContext_register;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeronContext = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@heronjs/common");
const declarations_1 = require("@heronjs/common/declarations");
const consts_1 = require("@heronjs/common/consts");
const module_context_1 = require("./module.context");
class HeronContext extends module_context_1.ModuleContext {
    constructor(_module, httpServer, wsServer, graphServer) {
        super(_module);
        this._module = _module;
        this.httpServer = httpServer;
        this.wsServer = wsServer;
        this.graphServer = graphServer;
        _HeronContext_logger.set(this, new common_1.Logger(HeronContext.name));
        _HeronContext_isAbort.set(this, true);
        this.get = () => this;
        this.modules = () => (0, common_1.__mixinIfAbsent)(this, {
            name: declarations_1.HERON_MODULES,
            refers: () => new Set()
        })[0];
        this.listen = async (obj) => {
            try {
                if (this.httpServer) {
                    await this.httpServer.listen(obj);
                    this.wsServer && await this.wsServer.listen(obj);
                    this.graphServer && await this.graphServer.listen(obj);
                }
            }
            catch (error) {
                tslib_1.__classPrivateFieldGet(this, _HeronContext_abortOnInitializeError, "f").call(this, error);
            }
            finally {
                tslib_1.__classPrivateFieldGet(this, _HeronContext_stats, "f").call(this);
            }
        };
        this.bootstrap = async () => {
            const context = await this.init();
            const modules = await tslib_1.__classPrivateFieldGet(this, _HeronContext_initialize, "f").call(this, context);
            await tslib_1.__classPrivateFieldGet(this, _HeronContext_register, "f").call(this, modules);
        };
        _HeronContext_stats.set(this, () => {
            const { routes, websocket, services } = global.HeronJS;
            (routes && routes.length > 0) && (0, common_1.__printf)('APIs', routes);
            (websocket && websocket.length > 0) && (0, common_1.__printf)('WebSockets', websocket);
            (services && services.length > 0) && (0, common_1.__printf)('Services', services);
        });
        _HeronContext_initialize.set(this, async (context) => {
            try {
                if (context && this.httpServer && this.root) {
                    this.httpServer.context = context;
                    const { rests, websockets, graphqls } = this.root;
                    const root = await this.root.build();
                    const { cacheStore: store, systemEvent } = root;
                    const adapterExtensions = {
                        store,
                        record: systemEvent,
                        ext: { di: this.di }
                    };
                    if (rests) {
                        for (const [_, value] of rests) {
                            if (!value.isResolve) {
                                await this.httpServer?.register(value.instance);
                            }
                            value.isResolve = true;
                        }
                    }
                    const worker = await this.httpServer.getAdapterWorker();
                    const engine = await this.httpServer.engine();
                    if (this.wsServer && websockets) {
                        await this.wsServer?.bind(context).connect(worker);
                        for (const [_, value] of websockets) {
                            await this.wsServer?.register(value.instance);
                        }
                        this.wsServer?.done();
                    }
                    if (this.graphServer && graphqls) {
                        await this.graphServer?.bind(context).connect(worker);
                        for (const [_, value] of graphqls) {
                            await this.graphServer?.register(value.instance);
                        }
                        await this.graphServer.combine(engine);
                    }
                    await tslib_1.__classPrivateFieldGet(this, _HeronContext_applyExtensionIfPossible, "f").call(this, [this.httpServer, this.wsServer, this.graphServer], adapterExtensions);
                }
                return context;
            }
            catch (err) {
                (err instanceof Error) && tslib_1.__classPrivateFieldGet(this, _HeronContext_abortOnInitializeError, "f").call(this, err);
            }
        });
        _HeronContext_applyExtensionIfPossible.set(this, async (servers, values) => {
            for (const server of servers) {
                if (server && server['extension'])
                    server.extension(values);
            }
        });
        _HeronContext_abortOnInitializeError.set(this, (error) => {
            if (tslib_1.__classPrivateFieldGet(this, _HeronContext_isAbort, "f")) {
                (error instanceof Error) && tslib_1.__classPrivateFieldGet(this, _HeronContext_logger, "f").fatal(error.message, error);
                (0, common_1.__forceShutdownGracefully)();
            }
            (0, consts_1.rethrow)(error);
        });
        _HeronContext_register.set(this, (module) => {
            const set = this.modules();
            if (set) {
                set.add(module);
            }
        });
    }
    context() {
        return this;
    }
}
exports.HeronContext = HeronContext;
_HeronContext_logger = new WeakMap(), _HeronContext_isAbort = new WeakMap(), _HeronContext_stats = new WeakMap(), _HeronContext_initialize = new WeakMap(), _HeronContext_applyExtensionIfPossible = new WeakMap(), _HeronContext_abortOnInitializeError = new WeakMap(), _HeronContext_register = new WeakMap();
