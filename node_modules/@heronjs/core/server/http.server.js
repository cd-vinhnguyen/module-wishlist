"use strict";
var _HttpServer_exists;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpServer = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@heronjs/common");
const declarations_1 = require("@heronjs/common/declarations");
const messages_consts_1 = require("@heronjs/common/consts/messages.consts");
const abstract_server_1 = require("./abstract.server");
const reflector_1 = require("@heronjs/common/reflector");
class HttpServer extends abstract_server_1.AbstractServer {
    constructor(_adapter) {
        super(HttpServer.name);
        this._adapter = _adapter;
        this.bind = (_context) => {
            this.di = _context.di;
            this._gatekeeper = _context.gatekeeper;
            return this;
        };
        this.extension = (values) => {
            return (this._adapter && this._adapter['extension']) && this._adapter?.extension(values);
        };
        this.listen = async (serverOptions) => {
            if (!this.isInit) {
                await this._adapter?.listen(serverOptions);
                this.isInit = true;
            }
        };
        this.engine = async () => {
            return (this._adapter && this._adapter['engine']) && this._adapter.engine();
        };
        this.register = async (controller) => {
            const [prefix, routes, runners, controllersInterceptors, routesInterceptors, guard, caches] = (0, reflector_1.__obtains)([declarations_1.CTRL_PREFIX, declarations_1.CTRL_ROUTES, declarations_1.OBJECT_RUNNER, declarations_1.CTRL_INTERCEPTORS, declarations_1.ROUTE_INTERCEPTORS, declarations_1.CTRL_GUARD, declarations_1.APP_CACHES], controller);
            if (this._adapter) {
                if (!routes || routes.length === 0)
                    this._logger.error((0, messages_consts_1.CAN_NOT_REGISTER_CONTROLLER)(controller.name));
                else {
                    const holder = this.di?.__getTarget(controller);
                    const controllerInterceptors = controllersInterceptors?.get(controller.name);
                    const routeHolders = routes?.map((route) => {
                        const { runner } = route;
                        const isExists = tslib_1.__classPrivateFieldGet(this, _HttpServer_exists, "f").call(this, prefix, route, controller.name);
                        if (isExists) {
                            throw new common_1.ModuleError(common_1.SYSErrors.SERVER_ERR, (0, messages_consts_1.CAN_NOT_REGISTER_CONTROLLER)(controller.name));
                        }
                        const _rst = (0, common_1.isSymbol)(runner) ? runner.toString() : runner;
                        const behaviors = runners[_rst];
                        const cache = caches?.find((x) => x.key === route.runner);
                        cache && (route.record = { cache: cache.value });
                        const _interceptors = [];
                        if (this._gatekeeper) {
                            if (guard) {
                                const protecting = this.__guardInterceptor(this._gatekeeper, guard, controller, _rst);
                                if (protecting) {
                                    _interceptors.push(protecting);
                                }
                            }
                        }
                        const routeKey = `${controller.name}:${_rst}`;
                        const routeInterceptors = routesInterceptors?.get(routeKey);
                        let joinedInterceptors = [];
                        (controllerInterceptors && controllerInterceptors.length > 0) && (joinedInterceptors = joinedInterceptors.concat(controllerInterceptors));
                        (routeInterceptors && routeInterceptors.length > 0) && (joinedInterceptors = joinedInterceptors.concat(routeInterceptors));
                        const caller = (holder)[runner];
                        return Object.freeze({
                            caller, guard, runner,
                            interceptors: (joinedInterceptors && joinedInterceptors.length > 0) ? [..._interceptors, ...joinedInterceptors] : _interceptors,
                            route, prefix, behaviors
                        });
                    });
                    const metas = { holder, type: common_1.HttpRouteType.API, prefix, actors: routeHolders };
                    const metadata = { metas };
                    await this._adapter.build(metadata);
                }
            }
        };
        this.getAdapterWorker = async () => {
            return this._adapter?.get();
        };
        _HttpServer_exists.set(this, (prefix, route, holder) => {
            const _registeredControllers = global.HeronJS.routes;
            const { path, method } = route;
            const isExits = _registeredControllers.some(x => x.uri === prefix + path && x.method === method);
            _registeredControllers.push({
                uri: prefix + path, holder, method,
                status: isExits ? 'duplicated' : 'listening'
            });
            return isExits;
        });
    }
}
exports.HttpServer = HttpServer;
_HttpServer_exists = new WeakMap();
