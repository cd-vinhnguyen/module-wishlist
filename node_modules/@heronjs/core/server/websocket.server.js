"use strict";
var _WebSocketServer_exists;
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketServer = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@heronjs/common");
const messages_consts_1 = require("@heronjs/common/consts/messages.consts");
const declarations_1 = require("@heronjs/common/declarations");
const abstract_server_1 = require("./abstract.server");
class WebSocketServer extends abstract_server_1.AbstractServer {
    constructor(_adapter) {
        super(WebSocketServer.name);
        this._adapter = _adapter;
        this.bind = (_context) => {
            this.di = _context.di;
            this._gatekeeper = _context.gatekeeper;
            return this;
        };
        this.connect = async (args) => {
            args && await this._adapter?.bind(args);
            return this;
        };
        this.listen = async (options) => {
            if (!this.isInit) {
                await this._adapter?.listen(options);
                this.isInit = true;
            }
        };
        this.extension = (values) => {
            return (this._adapter && this._adapter['extension']) && this._adapter?.extension(values);
        };
        this.register = async (controller) => {
            const [prefix, routes, behaviors, parameters, functionBehaviors, guards, caches] = (0, common_1.__obtains)([declarations_1.CTRL_PREFIX, declarations_1.CTRL_ROUTES, declarations_1.OBJECT_FUNCTIONS, declarations_1.FUNCTION_PARAMETERS, declarations_1.FUNCTION_META, declarations_1.CTRL_GUARD, declarations_1.APP_CACHES], controller);
            if (this._adapter) {
                if (!routes || routes.length === 0)
                    this._logger.error((0, messages_consts_1.CAN_NOT_REGISTER_CONTROLLER)(controller.name));
                else {
                    const holder = this.di?.__getTarget(controller);
                    const routeHolders = routes?.map((route) => {
                        const { key } = route;
                        const _rst = (0, common_1.isSymbol)(key) ? key.toString() : key;
                        const isExists = tslib_1.__classPrivateFieldGet(this, _WebSocketServer_exists, "f").call(this, prefix, route, controller.name);
                        if (isExists) {
                            (0, common_1.__forceShutdownGracefully)();
                        }
                        let _parameters = [];
                        if (parameters) {
                            _parameters = (0, common_1.__deep)(parameters[_rst]);
                            _parameters && delete parameters[_rst];
                        }
                        const guard = guards ? guards[key] || guards[controller.name] : undefined;
                        const cache = caches?.find((x) => x.key === route.key);
                        const wsRoute = {
                            holder,
                            record: { functionBehaviors, cache: cache?.value },
                            guard,
                            runner: _rst,
                            behavior: route,
                            parameters: _parameters
                        };
                        return Object.freeze(wsRoute);
                    });
                    const metas = {
                        metas: {
                            actors: routeHolders, behaviors, guards, holder,
                            prefix, transmitter: common_1.RealtimeTransmitter.WEBSOCKET
                        }
                    };
                    await this._adapter.build(metas);
                }
            }
        };
        this.done = () => {
            this.isInit = true;
        };
        _WebSocketServer_exists.set(this, (namespace, route, holder) => {
            const _registeredControllers = global.HeronJS.websocket;
            const { record } = route;
            const { uri, replyChannel } = record;
            const isExits = _registeredControllers.some(x => x.uri === `${namespace}/${uri}`);
            _registeredControllers.push({
                uri: `${namespace}/${uri}:${replyChannel}`, holder,
                status: isExits ? 'duplicated' : 'listening', replyChannel, replyTo: 'n/a', namespace
            });
            return isExits;
        });
    }
}
exports.WebSocketServer = WebSocketServer;
_WebSocketServer_exists = new WeakMap();
