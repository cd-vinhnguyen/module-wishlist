"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractServer = void 0;
const common_1 = require("@heronjs/common");
const validators_1 = require("@heronjs/common/utils/validators");
const http_status_codes_1 = require("http-status-codes");
class AbstractServer {
    constructor(_serverName) {
        this._serverName = _serverName;
        this.isInit = false;
        this.__guardInterceptor = (_gatekeeper, guards, ctrl, rst) => {
            if (_gatekeeper && guards) {
                const pkey = (0, common_1.isSymbol)(rst) ? rst.toString() : rst;
                let guard = guards[pkey];
                if (!guard) {
                    guard = guards[ctrl.name];
                    guard && (guards[pkey] = guards[ctrl.name]);
                }
                let interceptor;
                if (guard) {
                    interceptor = (req, res, next) => {
                        const { authContext } = res.locals;
                        if (authContext) {
                            const properties = guard.property;
                            let allow = false;
                            for (const [key, value] of Object.entries(properties)) {
                                const permissions = authContext[key];
                                if (permissions) {
                                    if (Array.isArray(value)) {
                                        allow = value.some(v => permissions?.indexOf(v) !== -1);
                                    }
                                    else if ((0, common_1.isBoolean)(value)) {
                                        allow = value;
                                    }
                                    else if ((0, validators_1.isFunction)(value) && (0, common_1.isPromise)(value)) {
                                        value.apply(null, [permissions])
                                            .then((allow) => allow
                                            ? next()
                                            : res.status(http_status_codes_1.StatusCodes.FORBIDDEN).send());
                                    }
                                    else if ((0, common_1.isNumeric)(value)) {
                                        allow = permissions === value;
                                    }
                                }
                            }
                            return allow ? next() : res.status(http_status_codes_1.StatusCodes.FORBIDDEN).send();
                        }
                    };
                }
                return interceptor;
            }
        };
        this._logger = new common_1.Logger(_serverName);
    }
    get context() {
        return this._context;
    }
    set context(value) {
        this._context = value;
        this.bind(value);
    }
}
exports.AbstractServer = AbstractServer;
