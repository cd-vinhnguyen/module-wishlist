"use strict";
var _ErrorHandler_logger, _ErrorHandler_handle;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorHandler = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("@heronjs/common/errors");
const common_1 = require("@heronjs/common");
const FORCE_STOP = () => process.exit(1);
class ErrorHandler {
    constructor() {
        _ErrorHandler_logger.set(this, new common_1.Logger(ErrorHandler.name));
        this.acceptAsync = async (callback, teardown = FORCE_STOP) => {
            try {
                await callback();
            }
            catch (e) {
                (e instanceof Error) && tslib_1.__classPrivateFieldGet(this, _ErrorHandler_handle, "f").call(this, e);
                teardown(e);
            }
        };
        _ErrorHandler_handle.set(this, (e) => {
            if (!(e instanceof errors_1.RuntimeError)) {
                tslib_1.__classPrivateFieldGet(this, _ErrorHandler_logger, "f").error(e.message, e);
            }
            else {
                tslib_1.__classPrivateFieldGet(this, _ErrorHandler_logger, "f").error(`${e.name}${e.code}${e.message}`, e);
            }
        });
        this.captureAllUncaughtException = () => {
            process.on('uncaughtException', (error) => {
                tslib_1.__classPrivateFieldGet(this, _ErrorHandler_logger, "f").error(error.message, error);
            });
        };
        this.captureAllUncaughtException();
    }
    accept(callback, teardown = FORCE_STOP) {
        try {
            callback();
        }
        catch (e) {
            (e instanceof Error) && tslib_1.__classPrivateFieldGet(this, _ErrorHandler_handle, "f").call(this, e);
            teardown(e);
        }
    }
}
exports.ErrorHandler = ErrorHandler;
_ErrorHandler_logger = new WeakMap(), _ErrorHandler_handle = new WeakMap();
