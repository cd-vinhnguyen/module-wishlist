"use strict";
var _SystemRegistry_instances, _SystemRegistry_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SystemRegistry = void 0;
const tslib_1 = require("tslib");
const registry_1 = require("@heronjs/common/registry");
const common_1 = require("@heronjs/common");
const declarations_1 = require("@heronjs/common/declarations");
const messages_consts_1 = require("@heronjs/common/consts/messages.consts");
let SystemRegistry = class SystemRegistry extends registry_1.AbstractRegistry {
    constructor() {
        super();
        _SystemRegistry_instances.add(this);
    }
    register(target, name, type) {
        const key = type;
        let instance;
        let meta;
        const _entries = this.get(key);
        switch (key) {
            case registry_1.RegistryType.REST: {
                const uniqueName = _entries.has(target.name) ? `${target.name}:${Math.floor(Math.random() * 3000)}` : target.name;
                instance = this.instanceBuilder({ target, scope: common_1.Scope.TRANSIENT, holder: this });
                _entries && _entries.set(uniqueName, instance);
                break;
            }
            case registry_1.RegistryType.DAO: {
                meta = (0, common_1.providerMeta)(target);
                if (!meta)
                    throw new common_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.CREATE_PROVIDER_FAILED)('Metadata is undefined'));
                instance = this.instanceBuilder({ target, scope: common_1.Scope.TRANSIENT, holder: this, meta });
                _entries && _entries.set(meta.token || target.name, instance);
                break;
            }
            case registry_1.RegistryType.GRAPHQL: {
                const [type, resolvers] = (0, common_1.__obtains)([declarations_1.GRAPHQL_TYPES, declarations_1.GRAPHQL_RESOLVERS], target);
                if (!resolvers)
                    throw new common_1.ModuleError(common_1.SYSErrors.MODULE_ERR, `Invalid GraphQL Declaration ${type.name}`);
                instance = this.instanceBuilder({
                    target, scope: common_1.Scope.TRANSIENT, holder: this, meta: { type, resolvers }
                });
                _entries && _entries.set(target.name, instance);
                break;
            }
            case registry_1.RegistryType.MODULES_EXPORT:
            case registry_1.RegistryType.MODULES_IMPORT:
                instance = this.instanceBuilder({ target, scope: common_1.Scope.SINGLETON, holder: target });
                _entries && _entries.set(target.name, instance);
                break;
            case registry_1.RegistryType.PROVIDER: {
                meta = (0, common_1.providerMeta)(target);
                instance = this.instanceBuilder({
                    target,
                    scope: meta.scope ? meta.scope : common_1.Scope.TRANSIENT,
                    holder: this,
                    meta
                });
                _entries && _entries.set(meta.token || target.name, instance);
                break;
            }
            case registry_1.RegistryType.REPOSITORY: {
                meta = (0, common_1.providerMeta)(target);
                instance = this.instanceBuilder({
                    target,
                    scope: meta.scope ? meta.scope : common_1.Scope.SINGLETON,
                    holder: this,
                    meta
                });
                _entries && _entries.set(meta.token || target.name, instance);
                break;
            }
            case registry_1.RegistryType.WEBSOCKET: {
                const [prefix, controllers, actors] = (0, common_1.__obtains)([declarations_1.CTRL_PREFIX, declarations_1.CTRL_WEBSOCKET, declarations_1.OBJECT_RUNNER], target);
                instance = this.instanceBuilder({
                    target,
                    scope: common_1.Scope.TRANSIENT,
                    holder: this,
                    meta: { prefix, actors, controllers }
                });
                _entries && _entries.set(target.name, instance);
                break;
            }
            case registry_1.RegistryType.DATABASE: {
                const [config, isDefault] = (0, common_1.__obtains)([declarations_1.SELF_CONFIG, declarations_1.DEFAULT_PROVIDER], target);
                if (!config)
                    throw new common_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, messages_consts_1.CREATE_DATABASE_CONNECTION_FAILED)(config));
                instance = this.instanceBuilder({
                    target, scope: common_1.Scope.SINGLETON, holder: this, meta: { config, isDefault }, init: (target) => {
                        if (target) {
                            const { instance, meta } = target;
                            (0, common_1.__mixinIfAbsent)(instance, { name: declarations_1.SELF_CONFIG, refers: () => meta });
                            (0, common_1.__annotation)((0, common_1.DatabaseObject)(), instance);
                            return instance;
                        }
                    }
                });
                _entries && _entries.set(target.name, instance);
                break;
            }
            case registry_1.RegistryType.ORM: {
                const [meta, config, isDefault] = (0, common_1.__obtains)([declarations_1.SELF_META, declarations_1.SELF_CONFIG, declarations_1.DEFAULT_PROVIDER], target);
                if (!meta || !config)
                    throw new common_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.CREATE_ORM_INSTANCE_FAILED)(config));
                instance = this.instanceBuilder({
                    target,
                    scope: common_1.Scope.SINGLETON,
                    holder: this,
                    meta: { meta, config, isDefault }
                });
                _entries && _entries.set(meta.name || target.name, instance);
                break;
            }
            case registry_1.RegistryType.SERVICE: {
                const [meta, config, executeContext, eventName] = (0, common_1.__obtains)([declarations_1.SELF_META, declarations_1.SELF_CONFIG, declarations_1.OBJECT_RUNNER, declarations_1.SELF_EVENT], target);
                if (!meta)
                    throw new common_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(meta));
                instance = this.instanceBuilder({
                    target, scope: common_1.Scope.SINGLETON, holder: this, meta: {
                        ...meta,
                        config,
                        executeContext,
                        eventName
                    }
                });
                _entries && _entries.set(meta.name, instance);
                break;
            }
            case registry_1.RegistryType.STORE: {
                const instance = this.instanceBuilder({
                    target,
                    scope: common_1.Scope.SINGLETON,
                    holder: this,
                    meta: {
                        opts: target.config,
                        type: target.type,
                        name: target.name,
                        isDefault: target.isDefault || false
                    }
                });
                _entries && _entries.set(target.name, instance);
                break;
            }
            case registry_1.RegistryType.HTML: {
                const instance = this.instanceBuilder({
                    target, scope: common_1.Scope.REQUEST, holder: this
                });
                _entries && _entries.set(target.name, instance);
                break;
            }
            case registry_1.RegistryType.FACTORY: {
                const meta = (0, common_1.providerMeta)(target);
                const instance = this.instanceBuilder({
                    target, holder: this, scope: (meta && meta.scope) ? meta.scope : common_1.Scope.TRANSIENT, meta
                });
                _entries && _entries.set(target.name, instance);
                break;
            }
            default:
                throw new common_1.ModuleError(common_1.SYSErrors.NOT_SUPPORTED_ERROR, (0, messages_consts_1.FUNCTION_NOT_SUPPORTED)(key));
        }
        tslib_1.__classPrivateFieldGet(this, _SystemRegistry_instances, "m", _SystemRegistry_set).call(this, key, _entries);
    }
    get(key) {
        return super.get(key) || new Map();
    }
};
_SystemRegistry_instances = new WeakSet(), _SystemRegistry_set = function _SystemRegistry_set(key, value) {
    this.registry && this.registry.set(key, value);
};
SystemRegistry = tslib_1.__decorate([
    (0, common_1.Provider)({ token: common_1.SYSTEM_REGISTRY }),
    tslib_1.__metadata("design:paramtypes", [])
], SystemRegistry);
exports.SystemRegistry = SystemRegistry;
