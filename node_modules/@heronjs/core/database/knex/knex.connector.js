"use strict";
var _KnexConnector_instances, _KnexConnector_client, _KnexConnector_build, _KnexConnector_toKnexConfig, _KnexConnector_create, _KnexConnector_createSlaves, _KnexConnector_rewrite, _KnexConnector_isTransactionQuery, _KnexConnector_isTransactionQueries;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnexConnector = exports.DATABASE_QUERIES = void 0;
const tslib_1 = require("tslib");
const consts_1 = require("@heronjs/common/consts");
const knex_1 = tslib_1.__importDefault(require("knex"));
const common_1 = require("@heronjs/common");
exports.DATABASE_QUERIES = ['insert', 'del', 'delete', 'update'];
class KnexConnector {
    constructor(_databaseConfig) {
        this._databaseConfig = _databaseConfig;
        _KnexConnector_instances.add(this);
        this.$mode = consts_1.ConnectionMode.STANDALONE;
        this.$pooling = { min: 1, max: 10 };
        _KnexConnector_client.set(this, consts_1.DatabaseDriver.MYSQL);
        this.connect = () => tslib_1.__classPrivateFieldGet(this, _KnexConnector_instances, "m", _KnexConnector_build).call(this);
        _KnexConnector_toKnexConfig.set(this, (commonConfig) => {
            const { driver, port, host, user, password, database, tls, pooling, typeCast } = commonConfig.config;
            if (pooling)
                this.$pooling = pooling;
            let conf = {
                host, port, user, password, database
            };
            switch (driver) {
                case consts_1.DatabaseDriver.MARIADB:
                    this.client = consts_1.DatabaseDriver.MYSQL;
                    conf = {
                        host, port, user, password,
                        ssl: tls?.enabled && tls?.ssl ? {
                            ca: tls?.ssl
                        } : undefined,
                        typeCast: typeCast ? typeCast.cast : undefined,
                        db: database
                    };
                    break;
                case consts_1.DatabaseDriver.MYSQL:
                    conf = {
                        host, port, user, password, database,
                        ssl: tls?.enabled && tls?.ssl ? {
                            ca: tls?.ssl
                        } : undefined,
                        typeCast: typeCast ? typeCast.cast : undefined
                    };
                    break;
                case consts_1.DatabaseDriver.ORACLE:
                    this.client = consts_1.DatabaseDriver.ORACLE;
                    break;
                case consts_1.DatabaseDriver.POSTGRES:
                    this.client = consts_1.DatabaseDriver.POSTGRES;
                    conf = {
                        host, port, user, password, database,
                        ssl: tls?.enabled && tls?.ssl ? {
                            require: true,
                            rejectUnauthorized: false,
                            ca: tls?.ssl
                        } : undefined,
                        typeCast: typeCast ? typeCast.cast : undefined
                    };
                    break;
                case consts_1.DatabaseDriver.SQLITE:
                    this.client = consts_1.DatabaseDriver.SQLITE;
                    break;
                default:
                    throw new common_1.SQLError(common_1.SQLErrors.CONNECTION_ERR, (0, consts_1.INVALID_DATABASE_DRIVER)(`${driver}`));
            }
            return conf;
        });
        _KnexConnector_create.set(this, (config) => {
            return (0, knex_1.default)(config);
        });
        _KnexConnector_createSlaves.set(this, (configs, migrations) => {
            if (this.$cluster) {
                const { slaves } = this.$cluster;
                for (const dbc of configs) {
                    const { user, password, host, port, database } = dbc.config;
                    const copy = Object.assign({}, this.$config);
                    const knexConfig = { ...copy, user, password, host, port, database };
                    const slave = (0, knex_1.default)({
                        client: this.client,
                        connection: knexConfig,
                        pool: this.$pooling,
                        migrations
                    });
                    slaves.push(slave);
                }
            }
        });
        _KnexConnector_rewrite.set(this, (knex) => {
            if (this.$cluster) {
                if (this.$mode === consts_1.ConnectionMode.CLUSTER) {
                    const { master, slaves } = this.$cluster;
                    knex.client.transaction = (container, configT, outerTx) => {
                        return master.client.transaction(container, configT, outerTx);
                    };
                    knex.client.runner = (builder) => {
                        try {
                            const safe = slaves.length > 1 ? (slaves.length - 1) : 0;
                            const randomize = safe > 1 ? Math.round(Math.random() * safe) : 0;
                            if (builder._queryContext && builder._queryContext.useMaster === true) {
                                builder.client = master.client;
                                return master.client.runner(builder);
                            }
                            else if (builder._queryContext && builder._queryContext.useMaster === false) {
                                const slave = (slaves && slaves.length >= 1) ? slaves[randomize] : master;
                                builder.client = slave.client;
                                return slave.client.runner(builder);
                            }
                            const sql = builder.toSQL();
                            const useMaster = Array.isArray(sql) ? tslib_1.__classPrivateFieldGet(this, _KnexConnector_isTransactionQueries, "f").call(this, sql) : tslib_1.__classPrivateFieldGet(this, _KnexConnector_isTransactionQuery, "f").call(this, sql);
                            if (useMaster) {
                                builder.client = master.client;
                                return master.client.runner(builder);
                            }
                            else {
                                const slave = (slaves && slaves.length >= 1) ? slaves[randomize] : master;
                                builder.client = slave.client;
                                return slave.client.runner(builder);
                            }
                        }
                        catch (err) {
                            throw new common_1.SQLError(common_1.SQLErrors.CONNECTION_ERR, (err instanceof Error) ? err.message : `${err}`);
                        }
                    };
                    return knex;
                }
                else
                    return this.$cluster.master;
            }
        });
        _KnexConnector_isTransactionQuery.set(this, (object) => {
            return exports.DATABASE_QUERIES.includes(object.method);
        });
        _KnexConnector_isTransactionQueries.set(this, (array) => {
            for (const query of array) {
                if (tslib_1.__classPrivateFieldGet(this, _KnexConnector_isTransactionQuery, "f").call(this, query)) {
                    return true;
                }
            }
            return false;
        });
    }
    get client() {
        return tslib_1.__classPrivateFieldGet(this, _KnexConnector_client, "f");
    }
    set client(value) {
        tslib_1.__classPrivateFieldSet(this, _KnexConnector_client, value, "f");
    }
    get() {
        return this.$knex;
    }
    async close() {
        if (this.$cluster) {
            const { master, slaves } = this.$cluster;
            const tasks = [];
            if (master)
                tasks.push(master.destroy());
            if (slaves)
                slaves.forEach(slave => tasks.push(slave.destroy()));
            await Promise.all(tasks);
        }
        throw new common_1.SQLError(common_1.SQLErrors.CONNECTION_ERR, consts_1.CLOSE_EMPTY_CONNECTION_ERROR);
    }
}
exports.KnexConnector = KnexConnector;
_KnexConnector_client = new WeakMap(), _KnexConnector_toKnexConfig = new WeakMap(), _KnexConnector_create = new WeakMap(), _KnexConnector_createSlaves = new WeakMap(), _KnexConnector_rewrite = new WeakMap(), _KnexConnector_isTransactionQuery = new WeakMap(), _KnexConnector_isTransactionQueries = new WeakMap(), _KnexConnector_instances = new WeakSet(), _KnexConnector_build = function _KnexConnector_build() {
    if (this._databaseConfig) {
        const { config } = this._databaseConfig;
        const { cluster, pooling, migration } = config;
        if (pooling)
            this.$pooling = pooling;
        this.$config = tslib_1.__classPrivateFieldGet(this, _KnexConnector_toKnexConfig, "f").call(this, this._databaseConfig);
        const master = tslib_1.__classPrivateFieldGet(this, _KnexConnector_create, "f").call(this, {
            client: this.client,
            pooling: this.$pooling,
            connection: this.$config,
            migrations: migration
        });
        if (!this.$cluster) {
            this.$cluster = {
                master,
                slaves: []
            };
        }
        if (cluster) {
            this.$mode = consts_1.ConnectionMode.CLUSTER;
            const slaveConnections = (0, common_1.fromConnectionString)(cluster.slaves);
            tslib_1.__classPrivateFieldGet(this, _KnexConnector_createSlaves, "f").call(this, slaveConnections, migration);
        }
    }
    this.$knex = tslib_1.__classPrivateFieldGet(this, _KnexConnector_rewrite, "f").call(this, (0, knex_1.default)({ client: this.client }));
};
