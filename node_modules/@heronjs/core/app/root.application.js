"use strict";
var _RootApplication_instances, _RootApplication_logger, _RootApplication_isInit, _RootApplication_registry, _RootApplication_uuid, _RootApplication_di, _RootApplication_ctm, _RootApplication_bind, _RootApplication_cacheStore, _RootApplication_systemEvent, _RootApplication_addInitializeEvent, _RootApplication_addSystemEvent, _RootApplication_createCacheEventHandler, _RootApplication_createServiceHandler, _RootApplication_prepare, _RootApplication_registerStores, _RootApplication_registerViews, _RootApplication_registerRest, _RootApplication_registerProvider, _RootApplication_registerDatabases, _RootApplication_registerServices, _RootApplication_registerWebsocket, _RootApplication_registerGraphQLs;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootApplication = exports.SystemInitializeType = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@heronjs/common/di");
const common_1 = require("@heronjs/common");
const errors_1 = require("@heronjs/common/errors");
const uuid_1 = require("uuid");
const consts_1 = require("../consts");
const validators_1 = require("@heronjs/common/utils/validators");
const reflector_1 = require("@heronjs/common/reflector");
const declarations_1 = require("@heronjs/common/declarations");
const context_1 = require("../context");
const stores_1 = require("../cache/stores");
const messages_consts_1 = require("@heronjs/common/consts/messages.consts");
const rxjs_1 = require("rxjs");
const registry_1 = require("../registry");
const registry_2 = require("@heronjs/common/registry");
var SystemInitializeType;
(function (SystemInitializeType) {
    SystemInitializeType[SystemInitializeType["STORE"] = 0] = "STORE";
    SystemInitializeType[SystemInitializeType["DATABASE"] = 1] = "DATABASE";
    SystemInitializeType[SystemInitializeType["PROVIDER"] = 2] = "PROVIDER";
    SystemInitializeType[SystemInitializeType["SERVICE"] = 3] = "SERVICE";
    SystemInitializeType[SystemInitializeType["FACTORY"] = 4] = "FACTORY";
    SystemInitializeType[SystemInitializeType["DAO"] = 5] = "DAO";
    SystemInitializeType[SystemInitializeType["REPOSITORY"] = 6] = "REPOSITORY";
})(SystemInitializeType = exports.SystemInitializeType || (exports.SystemInitializeType = {}));
class RootApplication {
    constructor(args) {
        this.args = args;
        _RootApplication_instances.add(this);
        _RootApplication_logger.set(this, new common_1.Logger(RootApplication.name));
        _RootApplication_isInit.set(this, false);
        _RootApplication_registry.set(this, void 0);
        _RootApplication_uuid.set(this, void 0);
        _RootApplication_di.set(this, void 0);
        this.SYSTEM_EVENT_NAME = '$$system.$$event';
        _RootApplication_ctm.set(this, void 0);
        _RootApplication_cacheStore.set(this, void 0);
        _RootApplication_systemEvent.set(this, void 0);
        this.build = async () => {
            if (!tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")) {
                throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, messages_consts_1.MODULE_INJECTOR_ERROR)(tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")));
            }
            const createDefault = async () => {
                const eventCtx = new context_1.EventContext();
                tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__constantValue({ token: common_1.EVENT_CONTEXT, value: eventCtx });
                await createSystemEvent(eventCtx);
            };
            const createSystemEvent = async (ctx) => {
                if (ctx) {
                    const systemEvent = ctx.register(this.SYSTEM_EVENT_NAME);
                    const _initializing = async (data) => {
                        const { data: systemData } = data;
                        if (systemData) {
                            const { type, value } = systemData;
                            try {
                                switch (type) {
                                    case SystemInitializeType.STORE:
                                        await createStores(value);
                                        break;
                                    case SystemInitializeType.DATABASE:
                                        await createDatabases(value);
                                        break;
                                    case SystemInitializeType.PROVIDER:
                                        await createProviders(value);
                                        break;
                                    case SystemInitializeType.SERVICE:
                                        await createServices(value);
                                        break;
                                    case SystemInitializeType.FACTORY:
                                        await createFactories(value);
                                        break;
                                    case SystemInitializeType.DAO:
                                        await createDaos(value);
                                        break;
                                    case SystemInitializeType.REPOSITORY:
                                        await createRepositories(value);
                                        break;
                                }
                            }
                            catch (e) {
                                tslib_1.__classPrivateFieldGet(this, _RootApplication_logger, "f").fatal((0, consts_1.CAN_NOT_START_MODULE)(type), e);
                            }
                        }
                    };
                    const _caching = async (data) => {
                        if (tslib_1.__classPrivateFieldGet(this, _RootApplication_ctm, "f")) {
                            const [client, cache] = tslib_1.__classPrivateFieldGet(this, _RootApplication_ctm, "f");
                            const { ttl, key, validate, value, behavior } = data.data;
                            if (key) {
                                switch (+behavior) {
                                    case common_1.CacheBehavior.CACHING:
                                        try {
                                            if (value) {
                                                const cacheKey = ((0, common_1.isString)(key)) ? key : await key(value);
                                                await cache?.set(cacheKey, validate ? await validate(value) : value, {
                                                    ttl: ttl || 300
                                                });
                                            }
                                        }
                                        catch (error) {
                                            (error instanceof Error) && tslib_1.__classPrivateFieldGet(this, _RootApplication_logger, "f").error(error.message, error);
                                        }
                                        break;
                                    case common_1.CacheBehavior.EVICT:
                                        try {
                                            const store = cache?.store;
                                            if (store) {
                                                const tmpKey = (0, common_1.isString)(key) ? key : await key(value);
                                                if ((0, common_1.isString)(tmpKey)) {
                                                    if ((0, common_1.HasWildcard)(tmpKey)) {
                                                        let delKeys;
                                                        if (tmpKey === '*') {
                                                            await cache?.reset();
                                                        }
                                                        else {
                                                            switch (client) {
                                                                case common_1.CacheClient.MEMORY:
                                                                case common_1.CacheClient.DISK:
                                                                case common_1.CacheClient.HAZELCAST:
                                                                    const searchKey = tmpKey.substring(0, tmpKey.indexOf('*'));
                                                                    if (searchKey && searchKey.length > 0) {
                                                                        const storeKeys = (store['keys']) && await store.keys();
                                                                        if (storeKeys) {
                                                                            delKeys = storeKeys.filter(x => x.startsWith(searchKey));
                                                                        }
                                                                    }
                                                                    break;
                                                                case common_1.CacheClient.REDIS:
                                                                    delKeys = (store['keys']) && await store.keys(tmpKey);
                                                                    break;
                                                            }
                                                        }
                                                        (delKeys && delKeys.length > 0) && delKeys.forEach(key => cache?.del(key));
                                                    }
                                                    else {
                                                        await cache?.del(tmpKey);
                                                    }
                                                }
                                                else {
                                                    tslib_1.__classPrivateFieldGet(this, _RootApplication_logger, "f").warning('the evict key is not string!');
                                                }
                                            }
                                        }
                                        catch (error) {
                                            (error instanceof Error) && tslib_1.__classPrivateFieldGet(this, _RootApplication_logger, "f").error(error.message, error);
                                        }
                                        break;
                                }
                            }
                        }
                    };
                    const _terminating = async (data) => {
                        tslib_1.__classPrivateFieldGet(this, _RootApplication_logger, "f").info(`received terminating signal ${JSON.stringify(data)}`);
                    };
                    systemEvent.listen(common_1.SystemEventType.INITIALIZING, _initializing);
                    systemEvent.listen(common_1.SystemEventType.TERMINATING, _terminating);
                    systemEvent.listen(common_1.SystemEventType.CACHING, _caching);
                    tslib_1.__classPrivateFieldSet(this, _RootApplication_systemEvent, systemEvent, "f");
                    tslib_1.__classPrivateFieldGet(this, _RootApplication_createCacheEventHandler, "f").call(this, systemEvent);
                }
            };
            const createStores = async (stores) => {
                if (stores) {
                    for await (const [_, value] of stores) {
                        const store = value;
                        if (store) {
                            const { meta } = store;
                            const { opts, type, name, isDefault } = meta;
                            const { client, config } = opts;
                            switch (type) {
                                case common_1.StoreType.CACHE: {
                                    let cacheStore;
                                    switch (client) {
                                        case common_1.CacheClient.MEMORY:
                                            cacheStore = await stores_1.MemoryStore.create(config);
                                            break;
                                        case common_1.CacheClient.HAZELCAST:
                                            cacheStore = await stores_1.HazelCastStore.create(config);
                                            break;
                                        case common_1.CacheClient.DISK:
                                            cacheStore = await stores_1.DiskStore.create(config);
                                            break;
                                        case common_1.CacheClient.REDIS:
                                            cacheStore = await stores_1.RedisStore.create(config);
                                            break;
                                    }
                                    if (cacheStore) {
                                        tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__constantValue({
                                            token: declarations_1.CACHE_STORE,
                                            value: cacheStore,
                                            named: name, isDefault
                                        });
                                        if (isDefault) {
                                            tslib_1.__classPrivateFieldSet(this, _RootApplication_ctm, [client, cacheStore.get()], "f");
                                            tslib_1.__classPrivateFieldSet(this, _RootApplication_cacheStore, cacheStore, "f");
                                        }
                                    }
                                    break;
                                }
                                case common_1.StoreType.STORAGE: {
                                    let storageStore;
                                    switch (client) {
                                        case context_1.StorageClient.AZURE:
                                            break;
                                        case context_1.StorageClient.FTP:
                                            break;
                                        case context_1.StorageClient.GCS:
                                            break;
                                        case context_1.StorageClient.S3:
                                            break;
                                        case context_1.StorageClient.SFTP:
                                            break;
                                        default:
                                            throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, messages_consts_1.FUNCTION_NOT_SUPPORTED)(name));
                                    }
                                    if (storageStore) {
                                        tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__constantValue({
                                            token: declarations_1.STORAGE_STORE,
                                            value: storageStore,
                                            named: name, isDefault: config.isDefault
                                        });
                                    }
                                    break;
                                }
                            }
                            store.isResolve = true;
                        }
                    }
                }
            };
            const createDatabases = async (databases) => {
                let isRootDB = true;
                databases && databases.forEach((database, _) => {
                    const { scope, isResolve, init, meta } = database;
                    if (!isResolve) {
                        if (init && (0, validators_1.isFunction)(init)) {
                            const connector = init(database);
                            const { isDefault } = meta;
                            tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__bindingWithDefault(connector, scope, common_1.MODULE_DATABASE, isDefault);
                        }
                    }
                    isRootDB = false;
                    database.isResolve = true;
                });
            };
            const createProviders = async (providers) => {
                providers && providers.forEach((provider) => {
                    const { scope, isResolve, instance, meta } = provider;
                    if (!isResolve) {
                        (meta && meta.token) ? tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__binding(instance, scope, meta.token)
                            : tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__selfWithScope(instance, scope);
                    }
                    provider.isResolve = true;
                });
            };
            const createDaos = createProviders;
            const createRepositories = createProviders;
            const createFactories = async (factories) => {
                if (factories) {
                    const factoryProps = {};
                    const buildProps = (factory) => {
                        const { meta, instance } = factory;
                        const { name, scope, token, isDefault } = meta;
                        const props = factoryProps[token] || [];
                        props.push({ token, name, instance, scope, isDefault });
                        factoryProps[token] = props;
                    };
                    for (const factory of factories.values()) {
                        buildProps(factory);
                    }
                    Object.keys(factoryProps).forEach((factory) => {
                        const bindings = factoryProps[factory];
                        tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__factoryBinding(factory, bindings);
                    });
                }
            };
            const createServices = async (services) => {
                if (services) {
                    for await (const [_, value] of services) {
                        const { isResolve, instance, meta } = value;
                        if (!isResolve) {
                            await tslib_1.__classPrivateFieldGet(this, _RootApplication_createServiceHandler, "f").call(this, instance, meta);
                        }
                    }
                }
            };
            try {
                await createDefault();
                this.stores && await tslib_1.__classPrivateFieldGet(this, _RootApplication_addInitializeEvent, "f").call(this, {
                    data: {
                        type: SystemInitializeType.STORE,
                        value: this.stores
                    }
                });
                this.databases && await tslib_1.__classPrivateFieldGet(this, _RootApplication_addInitializeEvent, "f").call(this, {
                    data: {
                        type: SystemInitializeType.DATABASE,
                        value: this.databases
                    }
                });
                this.daos && await tslib_1.__classPrivateFieldGet(this, _RootApplication_addInitializeEvent, "f").call(this, {
                    data: {
                        type: SystemInitializeType.DAO,
                        value: this.databases
                    }
                });
                this.providers && await tslib_1.__classPrivateFieldGet(this, _RootApplication_addInitializeEvent, "f").call(this, {
                    data: {
                        type: SystemInitializeType.PROVIDER,
                        value: this.providers
                    }
                });
                this.repositories && await tslib_1.__classPrivateFieldGet(this, _RootApplication_addInitializeEvent, "f").call(this, {
                    data: {
                        type: SystemInitializeType.REPOSITORY,
                        value: this.repositories
                    }
                });
                this.factories && await tslib_1.__classPrivateFieldGet(this, _RootApplication_addInitializeEvent, "f").call(this, {
                    data: {
                        type: SystemInitializeType.FACTORY,
                        value: this.factories
                    }
                });
                this.services && await createServices(this.services);
            }
            catch (err) {
                (err instanceof errors_1.RuntimeError) && tslib_1.__classPrivateFieldGet(this, _RootApplication_logger, "f").fatal(err.message, err);
                (0, common_1.__abortProcess)();
            }
            tslib_1.__classPrivateFieldSet(this, _RootApplication_isInit, true, "f");
            return this;
        };
        _RootApplication_addInitializeEvent.set(this, async (message) => {
            await tslib_1.__classPrivateFieldGet(this, _RootApplication_addSystemEvent, "f").call(this, common_1.SystemEventType.INITIALIZING, message);
        });
        _RootApplication_addSystemEvent.set(this, async (type, message) => {
            if (tslib_1.__classPrivateFieldGet(this, _RootApplication_systemEvent, "f")) {
                tslib_1.__classPrivateFieldGet(this, _RootApplication_systemEvent, "f").emit(type, message);
            }
        });
        _RootApplication_createCacheEventHandler.set(this, (systemEvent) => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__constantValue({
                token: common_1.SERVICE_CONTEXT_EVENTS,
                value: Object.freeze({
                    submit: (data) => {
                        systemEvent.emit(common_1.SystemEventType.CACHING, {
                            data: {
                                ...data,
                                behavior: common_1.CacheBehavior.CACHING
                            }
                        });
                    },
                    evict: (data) => {
                        systemEvent.emit(common_1.SystemEventType.CACHING, {
                            data: {
                                ...data,
                                behavior: common_1.CacheBehavior.EVICT
                            }
                        });
                    },
                    keys: async (key) => {
                        if (tslib_1.__classPrivateFieldGet(this, _RootApplication_ctm, "f")) {
                            const [, cacheStore] = tslib_1.__classPrivateFieldGet(this, _RootApplication_ctm, "f");
                            if (cacheStore) {
                                const store = cacheStore.store;
                                if (store && store['keys']) {
                                    return key ? await store.keys(key) : await store.keys();
                                }
                            }
                        }
                    }
                }),
                named: common_1.CACHE_EVENT_HANDLER
            });
        });
        _RootApplication_createServiceHandler.set(this, async (target, metas) => {
            const { type, executeContext, eventName } = metas;
            if (!executeContext)
                throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(target.name));
            const executionContext = executeContext.runners;
            const events = tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__get({ token: common_1.EVENT_CONTEXT });
            if (!events)
                throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, messages_consts_1.MODULE_INJECTOR_ERROR)('EventContext'));
            const event = events.register(target.name);
            const object = tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__getTarget(target);
            object && (0, common_1.__overrideIfExists)(object, 'useEvent', { value: event });
            const _setup = async () => {
                const _destroy = async () => {
                    const destroyContext = executionContext.filter(x => x.type === common_1.ServiceMethodIndicator.PreDestroy)[0];
                    if (!destroyContext)
                        throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(target.name) + ' @PreDestroy is required!');
                    const { key } = destroyContext;
                    (0, common_1.__dispatchAndForget)(object, key);
                };
                const _start = async () => {
                    const startContext = executionContext.filter(x => x.type === common_1.ServiceMethodIndicator.OnStart)[0];
                    if (!startContext)
                        throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(target.name) + ' @OnStart is required!');
                    const { key } = startContext;
                    (0, common_1.__dispatchAndForget)(object, key);
                };
                const _publisher = async (data) => {
                    const publisherContext = executionContext.filter(x => x.type === common_1.ServiceMethodIndicator.Publisher)[0];
                    if (!publisherContext)
                        throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(target.name) + ' @Publisher is required!');
                    const { key } = publisherContext;
                    (0, common_1.__dispatchAndForget)(object, key, [data]);
                };
                const _consumers = async () => {
                    const consumerContexts = executionContext.filter(x => x.type === common_1.ServiceMethodIndicator.Consumer);
                    if (!consumerContexts)
                        if (!consumerContexts)
                            throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(target.name) + ' at least one @Consumer is required!');
                    const consumerList = [];
                    for await (const context of consumerContexts) {
                        if (!context)
                            throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(target.name) + ' @Consumer is required!');
                        const { key, reflect } = context;
                        consumerList.push({
                            name: reflect || key, caller: (data) => (0, common_1.__dispatchAndForget)(object, key, [data])
                        });
                    }
                    return Object.freeze(consumerList);
                };
                const _createConsumers = async (events) => {
                    (events && events.length > 0) && events?.forEach(consumer => event.listen((consumer.name && ((0, common_1.isSymbol)(consumer.name) ? consumer.name.toString() : consumer.name)) || 'data', consumer.caller));
                };
                switch (type) {
                    case common_1.ServiceType.MESSAGING:
                        event.listen('publish', _publisher);
                    case common_1.ServiceType.SERVICE:
                        const consumers = await _consumers();
                        await _createConsumers(consumers);
                        event.listen('destroy', _destroy);
                        await _start();
                        break;
                    case common_1.ServiceType.INTERVAL:
                        const config = (0, reflector_1.__obtain)(declarations_1.SELF_CONFIG, target);
                        if (!config)
                            throw new errors_1.ModuleError(common_1.SYSErrors.MODULE_ERR, (0, common_1.INVALID_SERVICE_IDENTIFICATION)(target.name) + ' interval period is required!');
                        const $process = (0, rxjs_1.interval)(config.interval, rxjs_1.asyncScheduler).pipe((0, rxjs_1.switchMap)(() => _start())).subscribe();
                        event.listen('destroy', () => $process.unsubscribe());
                        break;
                }
            };
            await _setup();
            tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f")?.__constantValue({
                token: common_1.SERVICE_CONTEXT_EVENTS,
                value: (type === common_1.ServiceType.MESSAGING || type === common_1.ServiceType.INTERVAL) ? Object.freeze(event) : event,
                named: eventName ? eventName.name : target.name
            });
        });
        _RootApplication_prepare.set(this, (props) => {
            const { providers, controllers, dbs, renderViews, stores, services, realtimes, graphqls } = props;
            dbs && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerDatabases, "f").call(this, dbs);
            providers && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerProvider, "f").call(this, providers);
            controllers && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerRest, "f").call(this, controllers);
            renderViews && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerViews, "f").call(this, renderViews);
            stores && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerStores, "f").call(this, stores);
            services && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerServices, "f").call(this, services);
            realtimes && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerWebsocket, "f").call(this, realtimes);
            graphqls && tslib_1.__classPrivateFieldGet(this, _RootApplication_registerGraphQLs, "f").call(this, graphqls);
        });
        _RootApplication_registerStores.set(this, (stores) => stores.filter(x => x !== undefined).forEach(store => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(store, store.name, registry_2.RegistryType.STORE);
        }));
        _RootApplication_registerViews.set(this, (views) => views.filter(x => x !== undefined).forEach(view => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(view, view.name, registry_2.RegistryType.HTML);
        }));
        _RootApplication_registerRest.set(this, (rests) => rests.filter(x => x !== undefined).forEach(rest => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(rest, rest.name, registry_2.RegistryType.REST);
        }));
        _RootApplication_registerProvider.set(this, (providers) => providers.filter(x => x !== undefined).forEach(provider => {
            const type = (0, reflector_1.__obtain)(declarations_1.INSTANCE_TYPE, provider);
            switch (type) {
                case di_1.ProviderInstanceType.NPO:
                    tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(provider, provider.name, registry_2.RegistryType.PROVIDER);
                    break;
                case di_1.ProviderInstanceType.FPO:
                    tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(provider, provider.name, registry_2.RegistryType.FACTORY);
                    break;
                case di_1.ProviderInstanceType.RPO:
                    tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(provider, provider.name, registry_2.RegistryType.REPOSITORY);
                    break;
                case di_1.ProviderInstanceType.DPO:
                    tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(provider, provider.name, registry_2.RegistryType.DAO);
                    break;
            }
        }));
        _RootApplication_registerDatabases.set(this, (databases) => databases.forEach(db => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(db, db.name, registry_2.RegistryType.DATABASE);
        }));
        _RootApplication_registerServices.set(this, (services) => services.filter(x => x !== undefined).forEach(service => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(service, service.name, registry_2.RegistryType.SERVICE);
        }));
        _RootApplication_registerWebsocket.set(this, (wss) => wss.filter(x => x !== undefined).forEach(realtime => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(realtime, realtime.name, registry_2.RegistryType.WEBSOCKET);
        }));
        _RootApplication_registerGraphQLs.set(this, (graphqls) => graphqls.filter(x => x !== undefined).forEach(graphql => {
            tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").register(graphql, graphql.name, registry_2.RegistryType.GRAPHQL);
        }));
        tslib_1.__classPrivateFieldSet(this, _RootApplication_uuid, (0, uuid_1.v4)(), "f");
        tslib_1.__classPrivateFieldSet(this, _RootApplication_di, args.di, "f");
        tslib_1.__classPrivateFieldSet(this, _RootApplication_registry, new registry_1.SystemRegistry(), "f");
        tslib_1.__classPrivateFieldGet(this, _RootApplication_instances, "m", _RootApplication_bind).call(this);
        tslib_1.__classPrivateFieldGet(this, _RootApplication_prepare, "f").call(this, args);
    }
    get cacheStore() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_cacheStore, "f");
    }
    get systemEvent() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_systemEvent, "f");
    }
    get uuid() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_uuid, "f");
    }
    get rests() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.REST);
    }
    get websockets() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.WEBSOCKET);
    }
    get graphqls() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.GRAPHQL);
    }
    get stores() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.STORE);
    }
    get databases() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.DATABASE);
    }
    get orms() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.ORM);
    }
    get daos() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.DAO);
    }
    get providers() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.PROVIDER);
    }
    get factories() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.FACTORY);
    }
    get repositories() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.REPOSITORY);
    }
    get services() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.SERVICE);
    }
    get views() {
        return tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f").get(registry_2.RegistryType.HTML);
    }
}
exports.RootApplication = RootApplication;
_RootApplication_logger = new WeakMap(), _RootApplication_isInit = new WeakMap(), _RootApplication_registry = new WeakMap(), _RootApplication_uuid = new WeakMap(), _RootApplication_di = new WeakMap(), _RootApplication_ctm = new WeakMap(), _RootApplication_cacheStore = new WeakMap(), _RootApplication_systemEvent = new WeakMap(), _RootApplication_addInitializeEvent = new WeakMap(), _RootApplication_addSystemEvent = new WeakMap(), _RootApplication_createCacheEventHandler = new WeakMap(), _RootApplication_createServiceHandler = new WeakMap(), _RootApplication_prepare = new WeakMap(), _RootApplication_registerStores = new WeakMap(), _RootApplication_registerViews = new WeakMap(), _RootApplication_registerRest = new WeakMap(), _RootApplication_registerProvider = new WeakMap(), _RootApplication_registerDatabases = new WeakMap(), _RootApplication_registerServices = new WeakMap(), _RootApplication_registerWebsocket = new WeakMap(), _RootApplication_registerGraphQLs = new WeakMap(), _RootApplication_instances = new WeakSet(), _RootApplication_bind = function _RootApplication_bind() {
    tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f") && tslib_1.__classPrivateFieldGet(this, _RootApplication_di, "f").__binding(tslib_1.__classPrivateFieldGet(this, _RootApplication_registry, "f"), common_1.Scope.SINGLETON, common_1.SYSTEM_REGISTRY);
};
