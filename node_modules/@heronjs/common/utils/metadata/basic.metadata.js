"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._$handleMethodParameterChange = exports._$handleMethodMetaChange = exports.__append = void 0;
const consts_1 = require("../../consts");
const errors_1 = require("../../errors");
const decorators_1 = require("../../decorators");
const reflector_1 = require("../../reflector");
const validators_1 = require("../validators");
/**
 * append new metadata for property of target
 * @param args
 */
const __append = (args) => {
    const { target, metadata, data } = args;
    const { name, def } = metadata;
    if (!target)
        throw new errors_1.ReflectionError(consts_1.RTErrors.DEFINE_META_ERR, (0, decorators_1.CAN_NOT_APPLY_METADATA_ERROR)(target));
    if (!(0, reflector_1.__has)(name, target)) {
        (0, reflector_1.__mixin)(target, { name: name, refers: def });
    }
    const { type, runner } = data;
    let runners;
    const appendAsArray = Array.isArray(def);
    if (appendAsArray) {
        runners = (0, reflector_1.__obtain)(name, target);
        runners.push(runner);
    }
    else {
        runners = (0, reflector_1.__obtain)(name, target);
        const { key } = runner;
        let indexKey;
        if ((0, validators_1.isSymbol)(key)) {
            indexKey = key.toString();
        }
        else
            indexKey = key;
        let metas = runners[indexKey];
        if (!metas)
            metas = [];
        metas.push(Object.assign(Object.assign({}, runner), { type, key }));
        runners[indexKey] = metas;
    }
    (0, reflector_1.__mixin)(target, { name: name, refers: runners });
    return target;
};
exports.__append = __append;
/**
 * Handle and update method metadata
 * @param target
 * @param propertyKey
 * @param metaName
 * @param behavior
 * @param record
 */
const _$handleMethodMetaChange = (target, propertyKey, metaName, behavior, record) => {
    let resolvers = (0, reflector_1.__obtain)(metaName, target);
    if (!resolvers)
        resolvers = [];
    let methodMetas = resolvers.find(x => x.key === propertyKey);
    if (!methodMetas) {
        methodMetas = {
            key: propertyKey,
            ft: (0, consts_1.__funcBy)(target, propertyKey),
            behaviors: [behavior]
        };
    }
    else {
        methodMetas = Object.assign(Object.assign({}, methodMetas), { behaviors: methodMetas.behaviors ? [...methodMetas.behaviors, behavior] : [behavior] });
    }
    resolvers.push(Object.assign(Object.assign({}, methodMetas), { record }));
    (0, reflector_1.__mixin)(target.constructor, { name: metaName, refers: resolvers });
};
exports._$handleMethodMetaChange = _$handleMethodMetaChange;
/**
 * handle and update method parameters change
 * @param target
 * @param propertyKey
 * @param parameterIndex
 * @param metaName
 * @param type
 */
const _$handleMethodParameterChange = (target, propertyKey, parameterIndex, metaName, type) => {
    let resolvers = (0, reflector_1.__obtain)(metaName, target);
    if (!resolvers)
        resolvers = [];
    let methodMetas = resolvers.find(x => x.key === propertyKey);
    const parameter = {
        key: propertyKey,
        type,
        reflect: propertyKey,
        index: parameterIndex,
        resolved: false
    };
    if (!methodMetas) {
        methodMetas = {
            key: propertyKey,
            ft: (0, consts_1.__funcBy)(target, propertyKey),
            parameters: [parameter]
        };
    }
    else {
        methodMetas = Object.assign(Object.assign({}, methodMetas), { parameters: methodMetas.parameters ? [...methodMetas.parameters, parameter] : [parameter] });
    }
    resolvers.push(methodMetas);
    (0, reflector_1.__mixin)(target, { name: metaName, refers: resolvers });
};
exports._$handleMethodParameterChange = _$handleMethodParameterChange;
