"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._$safe = exports.__execute = exports.__dispatch = exports.__dispatchAndWait = exports.__dispatchAndForget = void 0;
const tslib_1 = require("tslib");
const consts_1 = require("../../consts");
const rxjs_1 = require("rxjs");
const errors_1 = require("../../errors");
const validators_1 = require("../validators");
const __dispatchAndForget = (target, key, args) => {
    const type = (0, consts_1.__funcBy)(target, key);
    switch (type) {
        case consts_1.FunctionType.prom:
        case consts_1.FunctionType.obs:
            (0, rxjs_1.defer)(() => {
                const fn = target[key];
                return fn.apply(target, args);
            }).subscribe();
            break;
        case consts_1.FunctionType.func:
            const fn = target[key];
            fn.apply(target, args);
            break;
    }
};
exports.__dispatchAndForget = __dispatchAndForget;
const __dispatchAndWait = (target, key, args) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const type = (0, consts_1.__funcBy)(target, key);
    if (type === consts_1.FunctionType.obs)
        throw new errors_1.FunctionError((0, consts_1.INVALID_SUPPORTED_FUNCTION_TYPE)('observer'));
    const fn = target[key];
    switch (type) {
        case consts_1.FunctionType.prom:
            return (0, validators_1.isFunction)(fn) && (yield fn.apply(target, args ? args : undefined));
        case consts_1.FunctionType.func:
            return (0, validators_1.isFunction)(fn) && fn.apply(target, args ? args : undefined);
    }
});
exports.__dispatchAndWait = __dispatchAndWait;
const __dispatch = (target, key, dispatchCtx) => {
    const { handler, parameters } = dispatchCtx;
    const type = (0, consts_1.__funcBy)(target, key);
    switch (type) {
        case consts_1.FunctionType.prom:
        case consts_1.FunctionType.obs:
            (0, rxjs_1.defer)(() => {
                const fn = target[key];
                return fn.apply(target, parameters ? parameters : undefined);
            }).subscribe({
                next: handler.next,
                error: handler.error
            });
            break;
        case consts_1.FunctionType.func:
            try {
                const fn = target[key];
                const result = fn.apply(target, parameters ? parameters : undefined);
                handler.next(result);
            }
            catch (error) {
                handler.error(error);
            }
            break;
    }
};
exports.__dispatch = __dispatch;
const __execute = (input) => {
    const { target, context, dispatchCtx } = input;
    return (0, exports.__dispatch)(target, context.key, dispatchCtx);
};
exports.__execute = __execute;
const _$safe = (args) => {
    const { target, name, params } = args;
    const hasProp = target[name];
    if ((0, validators_1.isFunction)(hasProp)) {
        return hasProp.apply(target, params);
    }
    else
        throw new errors_1.NotSupportedError('Can not safe run a non-function!');
};
exports._$safe = _$safe;
