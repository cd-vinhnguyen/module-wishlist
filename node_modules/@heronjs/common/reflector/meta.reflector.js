"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.__defineIfExists = exports.__objectRunner = exports.__selfConfig = exports.__selfMeta = exports.__extend = exports.__returnType = exports.__annotations = exports.__annotation = exports.__has = exports.__overrideIfExists = exports.__define = exports.__mixinIfAbsent = exports.__mixin = exports.__getProperty = exports.__obtains = exports.__obtain = exports.ExtendType = void 0;
const declarations_1 = require("../declarations");
var ExtendType;
(function (ExtendType) {
    ExtendType["obj"] = "Object";
    ExtendType["array"] = "Array";
})(ExtendType = exports.ExtendType || (exports.ExtendType = {}));
/**
 * obtain metadata from target
 * @param meta
 * @param target
 */
const __obtain = (meta, target) => {
    return Reflect.getOwnMetadata(meta, target) || Reflect.getMetadata(meta, target);
};
exports.__obtain = __obtain;
/**
 * obtain multiple metadata from target
 * @param metas
 * @param target
 */
const __obtains = (metas = [], target) => {
    return metas.map(e => (0, exports.__obtain)(e, target));
};
exports.__obtains = __obtains;
/**
 * get a property from target with property name
 * @param target
 * @param property
 */
const __getProperty = (target, property) => {
    return Reflect.get(target, property);
};
exports.__getProperty = __getProperty;
/**
 * mixin new metadata to a target
 * @param target
 * @param metas
 */
const __mixin = (target, ...metas) => {
    for (const meta of metas) {
        const { name, refers } = meta;
        const isExists = Reflect.hasOwnMetadata(name, target);
        if (!isExists) {
            Reflect.defineMetadata(name, refers, target);
        }
    }
};
exports.__mixin = __mixin;
/**
 * mixin new metadata if absent
 * @param target
 * @param metas
 */
const __mixinIfAbsent = (target, ...metas) => {
    const results = [];
    for (let i = 0; i < metas.length; i++) {
        const { name, refers } = metas[i];
        const isExists = Reflect.hasOwnMetadata(name, target);
        if (!isExists) {
            const func = refers();
            if (func) {
                Reflect.defineMetadata(name, func, target);
                results[i] = func;
            }
        }
    }
    return results;
};
exports.__mixinIfAbsent = __mixinIfAbsent;
/**
 * define new property with key and attributes to a target
 * @param target
 * @param key
 * @param attributes
 */
const __define = (target, key, attributes) => {
    return Reflect.defineProperty(target, key, attributes);
};
exports.__define = __define;
/**
 * override new property if exist
 * @param target
 * @param key
 * @param attributes
 */
const __overrideIfExists = (target, key, attributes) => {
    const exists = (0, exports.__has)(key, target);
    if (exists) {
        (0, exports.__define)(target, key, attributes);
    }
};
exports.__overrideIfExists = __overrideIfExists;
/**
 * check target has metadata with name
 * @param name
 * @param target
 */
const __has = (name, target) => {
    return Reflect.hasMetadata(name, target);
};
exports.__has = __has;
/**
 * decorate a decorator to a target
 * @param decorator
 * @param target
 */
const __annotation = (decorator, target) => {
    Reflect.decorate([decorator], target);
};
exports.__annotation = __annotation;
/**
 * decorate a array of decorators to a target
 * @param target
 * @param decorators
 */
const __annotations = (target, ...decorators) => {
    Reflect.decorate(decorators, target);
};
exports.__annotations = __annotations;
/**
 * get method return type
 * @param target
 * @param key
 */
const __returnType = (target, key) => {
    return key ? Reflect.getMetadata(declarations_1.DESIGN_RETURN_TYPE, target, key) : Reflect.getMetadata(declarations_1.DESIGN_RETURN_TYPE, target);
};
exports.__returnType = __returnType;
/**
 * extend a mixin metadata with new value
 * @param type
 * @param target
 * @param defineKey
 * @param values
 */
const __extend = (type, target, defineKey, values) => {
    const current = Reflect.getMetadata(defineKey, target);
    let update;
    switch (type) {
        case ExtendType.array:
            update = [...current, ...values];
            Reflect.defineMetadata(defineKey, update, target);
            break;
        case ExtendType.obj:
            update = Object.assign(Object.assign({}, current), { values });
            Reflect.defineMetadata(defineKey, update, target);
            break;
    }
};
exports.__extend = __extend;
const __selfMeta = (values, target) => {
    (0, exports.__mixin)(target, { name: declarations_1.SELF_META, refers: values });
};
exports.__selfMeta = __selfMeta;
const __selfConfig = (values, target) => {
    (0, exports.__mixin)(target, { name: declarations_1.SELF_CONFIG, refers: values });
};
exports.__selfConfig = __selfConfig;
const __objectRunner = (values, target) => {
    (0, exports.__mixin)(target, { name: declarations_1.OBJECT_RUNNER, refers: values });
};
exports.__objectRunner = __objectRunner;
const __defineIfExists = (prop, value, target) => {
    const exists = (0, exports.__has)(prop, target);
    exists && (0, exports.__define)(target, prop, { value });
};
exports.__defineIfExists = __defineIfExists;
