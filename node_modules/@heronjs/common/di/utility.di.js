"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Autowired = exports.FactoryLookup = exports.Inject = exports.StoreLookup = exports.CacheLookup = exports.CacheEventLookup = exports.EventLookup = exports.DatabaseLookup = exports.ConfigLookup = exports.Lookup = void 0;
const consts_1 = require("../consts");
const inversify_1 = require("inversify");
const errors_1 = require("../errors");
const declarations_1 = require("../declarations");
/**
 * lookup for instance in ioc with token and name
 * @param args
 * @constructor
 */
const Lookup = (args) => {
    const { token, name } = args;
    if (!token || !name)
        throw new errors_1.ReflectionError(consts_1.RTErrors.INJECTION_ERR, `Can not inject meta with ${token} ${name}`);
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(token))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            (0, inversify_1.named)(name)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.Lookup = Lookup;
/**
 * lookup system config by name
 * @param name
 * @constructor
 */
const ConfigLookup = (name) => {
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(consts_1.MODULE_CONFIGURATION))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            name && (0, inversify_1.named)(name)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.ConfigLookup = ConfigLookup;
/**
 * lookup for database
 * @param name
 * @constructor
 */
const DatabaseLookup = (name) => {
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(consts_1.MODULE_DATABASE))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            name && (0, inversify_1.named)(name)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.DatabaseLookup = DatabaseLookup;
/**
 * lookup for event
 * @param name
 * @constructor
 */
const EventLookup = (name) => {
    if (!name)
        throw new errors_1.ReflectionError(consts_1.RTErrors.INJECTION_ERR, `Can not inject meta with  ${name}`);
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(consts_1.SERVICE_CONTEXT_EVENTS))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            (0, inversify_1.named)(name)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            (0, inversify_1.optional)()(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.EventLookup = EventLookup;
/**
 * for cache event
 * @returns {ParameterDecorator}
 * @constructor
 */
const CacheEventLookup = () => {
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(consts_1.SERVICE_CONTEXT_EVENTS))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            (0, inversify_1.named)(consts_1.CACHE_EVENT_HANDLER)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.CacheEventLookup = CacheEventLookup;
/**
 * lookup for cache
 * @param name
 * @constructor
 */
const CacheLookup = (name) => {
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(declarations_1.CACHE_STORE))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            name && (0, inversify_1.named)(name)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.CacheLookup = CacheLookup;
/**
 * lookup for store instance
 * @param name
 * @constructor
 */
const StoreLookup = (name) => {
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(declarations_1.STORAGE_STORE))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            name && (0, inversify_1.named)(name)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.StoreLookup = StoreLookup;
/**
 * inject with token
 * @param token
 * @constructor
 */
const Inject = (token) => {
    return (target, propertyKey, parameterIndex) => {
        if (!token)
            throw new errors_1.ReflectionError(consts_1.RTErrors.INJECTION_ERR, `Can not inject meta with ${token}`);
        try {
            (0, inversify_1.inject)(Symbol.for(token))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.Inject = Inject;
const FactoryLookup = (token) => {
    return (target, propertyKey, parameterIndex) => {
        if (!token)
            throw new errors_1.ReflectionError(consts_1.RTErrors.INJECTION_ERR, `Can not inject factory with ${token}`);
        try {
            (0, inversify_1.inject)(Symbol.for(`Factory<${token}>`))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.FactoryLookup = FactoryLookup;
/**
 * autowired dependency injection
 * return undefined object if not available
 * @param {string} token
 * @param {string} name
 * @returns {ParameterDecorator}
 * @constructor
 */
const Autowired = (token, name) => {
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(token))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            name && (0, inversify_1.named)(Symbol.for(name))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            (0, inversify_1.optional)()(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
exports.Autowired = Autowired;
/**
 * plugin as dependency injection
 * @from <b>./plugins</b> directory
 * @param {string} name
 * @returns {ParameterDecorator}
 * @constructor
 * @deprecated
 */
const Plugin = (name) => {
    return (target, propertyKey, parameterIndex) => {
        try {
            (0, inversify_1.inject)(Symbol.for(consts_1.MODULE_PLUGINS))(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            (0, inversify_1.named)(name)(target, (0, consts_1.stString)(propertyKey), parameterIndex);
            (0, inversify_1.optional)()(target, (0, consts_1.stString)(propertyKey), parameterIndex);
        }
        catch (e) {
            (0, consts_1.rethrow)(e);
        }
    };
};
