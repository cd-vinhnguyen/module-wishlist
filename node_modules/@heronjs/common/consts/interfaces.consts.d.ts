import { Scope } from '../enums';
import { Any, EvictCacheValue, HttpInComing, PartialCacheValue, WebSocketInComing } from './type.consts';
import { Observable } from 'rxjs';
import { TracingConfiguration } from './tracer.types';
export interface ScopeOptions {
    scope?: Scope;
}
export interface OnValidation {
    validate: () => boolean;
}
export interface OnPolling<T> {
    polling: () => Promise<T>;
}
export interface OnBinding<T, R> {
    bind: (...args: T[]) => Promise<R>;
}
export interface OnError<T, R> {
    error: (error?: Error) => Promise<R>;
}
export interface OnSuccess<T, R> {
    success: (data?: T) => Promise<R>;
}
export interface Closable<R> {
    close: () => Promise<R>;
}
export interface Subscribable<T, R> {
    subscribe: (obj?: T) => R;
}
export interface Runnable {
    run: () => void;
}
export interface Startable<T, R> {
    start: (obj?: T) => Promise<R>;
}
export interface Listener<T, R> {
    listen: (obj?: T) => Promise<R>;
}
export interface OperationDispatcher<T> {
    dispatch: <P, R>(holder: P, meta?: T) => (fn: () => R, ...args: Any[]) => R;
}
export interface ViewDispatcher<T> {
    render: <P, R>(holder: P, meta?: T) => (fn: () => R, ...args: Any[]) => R;
}
export interface Dispatcher<T, R> {
    dispatch: (value?: T) => R;
}
export interface Servable<T, R> {
    serve: (options: T) => R;
}
export interface Consumable {
    consume: <I, O>(next: I) => O;
}
export interface Protector {
    protect: () => Promise<boolean> | boolean;
}
export interface Expiry<T> {
    expired: () => T;
}
export interface Registrable<T, R> {
    register: (target: T, name: string, type: unknown | string) => R;
}
export interface Usable<T, R> {
    use: (component: T) => R;
}
export interface Applicable {
    apply: <T>(target: T) => T;
}
export interface HasEngine<T> {
    engine: (engine: T) => void;
}
export interface HasHandler<T> {
    handler: (name: string) => T;
}
export interface OnRendering<T> {
    render: () => Observable<[string, T]>;
}
export interface Uploadable<T, R> {
    upload: (input?: T) => R;
}
export interface Downloadable<T, R> {
    download: (input?: T) => R;
}
export interface Streamable<T, R> {
    stream: (stream?: T) => R;
}
export interface Buildable<T, R> {
    build: (options?: T) => R;
}
export interface Stopable {
    stop: () => void;
}
export interface Combinable<T> {
    combine?: (value?: T) => Promise<Any>;
}
export interface Interceptor {
    (...args: Any[]): Any;
}
export interface IResolver<T, R> {
    resolve: (data?: T) => Promise<R | unknown>;
}
/**
 * @deprecated
 */
export interface Resolver<R> extends IResolver<string, R> {
    http?: [HttpInComing, string];
    ws?: [WebSocketInComing, string];
    resolve: (data?: string) => Promise<R | unknown>;
}
export interface AuthResolver<R> extends IResolver<string, R> {
    http?: [HttpInComing, string];
    ws?: [WebSocketInComing, string];
    resolve: (data?: string) => Promise<R | unknown>;
}
export interface EventHandler<T> {
    emit: (name: 'data' | 'destroy' | 'publish' | string, data?: Message<T>) => void;
    listen: (name: 'data' | 'destroy' | 'publish' | string, handler: Any) => void;
    dispose: () => void;
}
export interface Message<T> {
    data: T;
}
export interface CacheEventHandler {
    submit: (data: PartialCacheValue<Any>) => Promise<void>;
    evict: (data: EvictCacheValue<Any>) => Promise<void>;
    keys?: (key?: string) => Promise<string[] | undefined>;
}
export interface CacheKeyBuilder<T> {
    (data: T): Promise<string>;
}
export interface IRegistry<K, T, R> extends Registrable<T, R> {
    get(key: K): T;
}
export interface ITransform<In, Out> {
    transform: (input: In, ...args: Any[]) => Out;
}
export interface ICreatable<I, T> {
    create(props?: I): Promise<T>;
}
export interface IActivable<I, T> {
    activate(args?: I): Promise<T>;
}
export interface IDisposable<I, T> {
    dispose(args?: I): Promise<T>;
}
export interface IExtension<I, T> extends IActivable<I, T>, IDisposable<I, void> {
}
export interface IConnectable<A, T> {
    connect(args?: A): T | Promise<T>;
}
export interface HeronJSConfig {
    apm?: TracingConfiguration;
    extensions?: string[];
}
export interface IORM<I, T> {
    active(arg?: I): T;
}
