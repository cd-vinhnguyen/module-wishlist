"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseModel = exports.BaseEntity = exports.LimitedMap = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("../errors");
const errors_consts_1 = require("./errors.consts");
const utils_1 = require("../utils");
const messages_consts_1 = require("./messages.consts");
class LimitedMap {
    constructor(maxEntries = 200) {
        this.maxEntries = maxEntries;
        this.values = new Map();
        this.get = (key) => this.values.get(key);
        this.put = (key, value) => {
            if (this.values.size >= this.maxEntries) {
                const keyToDelete = Array.from(this.values.keys()).pop();
                keyToDelete && this.values.delete(keyToDelete);
            }
            this.values.set(key, value);
            return [key, value];
        };
    }
}
exports.LimitedMap = LimitedMap;
class BaseEntity {
    constructor() {
        this.getId = () => {
            if (typeof this.id === 'undefined') {
                throw new errors_1.ValidatorError(errors_consts_1.ConstrainErrors.INVALID_CONSTRAIN_ERR, 'Missing id');
            }
            return this.id;
        };
        this.getCreatedAt = () => {
            if (!this.createdAt || typeof this.createdAt === 'undefined') {
                this.createdAt = new Date().getTime();
            }
            return this.createdAt;
        };
        this.getUpdatedAt = () => {
            return this.updatedAt;
        };
        this.validate = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const details = yield utils_1.ClassValidator.validate(this);
            if (details) {
                throw new errors_1.ValidatorError(errors_consts_1.ConstrainErrors.INVALID_CONSTRAIN_ERR, details.error || messages_consts_1.NO_DETAIL_INFO);
            }
        });
    }
}
exports.BaseEntity = BaseEntity;
class BaseModel {
    constructor() {
        this.getId = () => {
            return this.id;
        };
        this.getCreatedAt = () => {
            return this.createdAt;
        };
        this.getUpdatedAt = () => {
            return this.updatedAt;
        };
        this.validate = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const details = yield utils_1.ClassValidator.validate(this);
            if (details) {
                throw new errors_1.ValidatorError(errors_consts_1.ConstrainErrors.INVALID_CONSTRAIN_ERR, details.error || messages_consts_1.NO_DETAIL_INFO);
            }
        });
    }
}
exports.BaseModel = BaseModel;
