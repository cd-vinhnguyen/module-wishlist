import { Scope } from '../enums';
import { FunctionType } from './enums.consts';
import { Any } from './type.consts';
/**
 * rethrow error
 * @param err
 */
export declare const rethrow: (err: unknown) => never;
/**
 * Flat arrays
 * @param arr
 */
export declare const flatten: <T = any>(arr: T[][]) => T[];
/**
 * get provider scope
 * @param provider
 */
export declare const getScope: (provider: Type<unknown>) => Scope;
/**
 * sort order ascending
 * @param a
 * @param b
 */
export declare const asc: (a: any, b: any) => 0 | 1 | -1;
/**
 * convert string to symbol
 * @param input
 */
export declare const toSymbol: (input: string) => symbol;
/**
 * convert union type string | symbol to string
 * check type if symbol then return string
 * @param symbol
 */
export declare const stString: (symbol: string | symbol) => string;
/**
 * Get function type
 * @param target
 * @param key
 */
export declare const __funcBy: (target: any, key: string | symbol) => FunctionType;
/**
 * merging array data by position
 * @param arrays
 * @param args
 */
export declare const __merging: (arrays: Any[], ...args: {
    position: number;
    value: Any;
}[]) => any[];
export interface Abstract<T> extends Function {
    prototype: T;
}
export declare type AbstractConstructor<T> = abstract new (...args: any[]) => T;
export interface Type<T = any> extends Function {
    new (...args: any[]): T;
}
export declare type Constructor<T> = new (...args: Any[]) => T;
