import { CacheBehavior, CacheClient, FunctionType, RealtimeMethodIndicator, ServiceMethodIndicator, ServiceType, StoreType } from './enums.consts';
import { CacheKeyBuilder, Message } from './interfaces.consts';
import { CacheClientOptions } from './options.consts';
import { ParameterContext } from './context.consts';
export declare type Optional<T> = T | undefined;
export declare type Nullable<T> = T | null;
export declare type Maybe<T> = T | undefined | null;
export declare type Tokenize = {
    token?: string | symbol;
};
export declare type Any = any;
export declare type RequestInComing = HttpInComing & WebSocketInComing;
export declare type HttpInComing = 'header' | 'cookie' | 'session';
export declare type WebSocketInComing = 'handshake' | 'header';
export declare type Paginate = {
    total?: number;
    offset: number;
    limit: number;
};
/**
 * iss: Issuer - Identifies principal that issued the JWT.
 * sub: Subject - Identifies the subject of the JWT.
 * aud: Audience - Identifies the recipients that the JWT is intended for. Each principal intended to process the JWT must identify itself with a value in the audience claim. If the principal processing the claim does not identify itself with a value in the aud claim when this claim is present, then the JWT must be rejected.
 * exp: Expiration Time - Identifies the expiration time on and after which the JWT must not be accepted for processing. The value must be a NumericDate:[9] either an integer or decimal, representing seconds past 1970-01-01 00:00:00Z.
 * nbf: Not Before - Identifies the time on which the JWT will start to be accepted for processing. The value must be a NumericDate.
 * iat: Issued At - Identifies the time at which the JWT was issued. The value must be a NumericDate.
 * jti: JWT Id - Case-sensitive unique identifier of the token even among different issuers.
 * attributes: Custom Claims
 *
 */
export declare type JWTToken = {
    [key: string]: any;
    iss?: string;
    sub?: string;
    aud?: string | string[];
    nbf?: number;
    exp?: number | string;
    iat?: number;
    jti?: string;
};
export declare type CacheConfiguration = {
    client: CacheClient;
    config: CacheClientOptions;
};
export declare type StorageConfiguration = {
    client: 's3' | 'aws' | 'gcs';
};
export declare type ModuleStore = {
    type: StoreType | string;
    name: string;
    isDefault?: boolean;
    config: CacheConfiguration;
};
export declare type ClassHolder = {
    alias: any;
    prototype: any;
};
export declare type CacheValue<T> = {
    key?: string | CacheKeyBuilder<T>;
    ttl?: number;
    value?: T;
    validate?: (value: T) => Promise<Any>;
    behavior: CacheBehavior;
};
export declare type PartialCacheValue<T> = Omit<CacheValue<T>, 'value' | 'behavior'>;
export declare type EvictCacheValue<T> = Pick<CacheValue<T>, 'key' | 'validate'>;
export declare type EventCacheValue<T> = Omit<CacheValue<T>, 'behavior' | 'validate'>;
export declare type CacheProperty = {
    key?: string | symbol;
    value?: CacheValue<Any>;
};
/**
 * Method interceptors
 */
export declare type InterceptorMap = Map<string, Any[]>;
export interface ServiceParameterMetadata {
    runners: ServiceParameter[];
}
export declare type TypeOfFunction = {
    functionType: FunctionType;
};
export declare type ServiceParameter = ParameterContext<ServiceMethodIndicator> & TypeOfFunction;
export declare type ServiceMetadata<T> = {
    name: string;
    type: ServiceType;
    metadata?: T;
};
export declare type DecoratorMetadata = {
    name: string;
    holder: string;
    type: 'method' | 'class' | 'parameter';
};
export declare type EventHolder<T, R> = {
    name: string | symbol;
    caller: (data: T) => R;
};
export declare type AppendableMetadata<T, R> = {
    target: Any;
    metadata: {
        name: string;
        def: Any;
    };
    data: {
        type: T;
        runner: R;
    };
};
export declare type RegisteredInstance = {
    holder?: string;
    method?: string;
};
export declare type RegisteredController = RegisteredInstance & {
    uri?: string;
    status?: 'duplicated' | 'listening' | 'error';
};
export declare type RegisteredWebSocket = RegisteredInstance & {
    namespace: string;
    uri: string;
    status?: 'duplicated' | 'listening' | 'error';
    replyChannel: string;
    replyTo: string;
};
export declare type RegisteredService = RegisteredInstance & {
    status?: 'created' | 'listening';
};
export declare type PaginateResponse<T> = {
    data?: T;
} & Paginate;
export declare type ServiceEventHolder = EventHolder<Message<Any>, void>;
export declare type RealtimeParameter = ParameterContext<RealtimeMethodIndicator> & TypeOfFunction;
export declare type Pair<T> = {
    key: string;
    value: T;
};
