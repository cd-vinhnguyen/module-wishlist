import { Combinable, Interceptor, Listener } from './interfaces.consts';
import { RequestRoute, ServerOptions, ViewRoute } from './http.consts';
import { Any, RealtimeParameter } from './type.consts';
import { HttpParameter, Route } from '../decorators';
import { HttpRouteType, RealtimeTransmitter } from './enums.consts';
import { GuardContext, GuardContextMetadata, ObjectMethodContext, ParameterContext } from './context.consts';
import { TracingConfiguration } from './tracer.types';
export interface Adapter<T, Server> {
    get: () => Promise<Server>;
    build: (meta: T) => Promise<void>;
    engine?: <O>(options?: O) => Promise<Any>;
    extension?: <S, R>(extension?: AdapterExtension<S, R>) => Promise<Any>;
}
export declare type AdapterExtension<S, R> = {
    store?: S | unknown;
    record?: R | unknown;
    ext?: Any | unknown;
};
export declare type HttpRouteDefinition = {
    guard?: GuardContext;
    interceptors?: Interceptor[];
    prefix: string;
};
export declare type HttpExecutionContext = {
    holder: Any;
    caller: Any;
    behaviors?: ParameterContext<HttpParameter>[];
};
export declare type HttpAPIRoute<Req, Res, Next> = HttpRouteDefinition & HttpExecutionContext & {
    route: RequestRoute<Req, Res, Next>;
};
export declare type HttpViewRoute<Req, Res, Next> = HttpRouteDefinition & HttpExecutionContext & {
    view: ViewRoute<Req, Res, Next>;
};
export declare type ObjectBehavior<T> = {
    runner: string | symbol;
    behavior?: T;
    parameters?: ParameterContext<Any>[];
};
export declare type HttpRouteActor = ObjectBehavior<ParameterContext<HttpParameter>[]> & {
    caller: Any;
    route: Route;
    guard?: GuardContext;
    interceptors?: Interceptor[];
};
export declare type HttpRouteMetadata = {
    prefix: string;
    holder: Any;
    type: HttpRouteType;
    actors: HttpRouteActor[];
};
export declare type HttpBuildMetadata = {
    metas: HttpRouteMetadata;
};
export interface HttpAdapter<Interceptor, Server> extends Adapter<HttpBuildMetadata, Server>, Listener<ServerOptions, Server>, Combinable<Any> {
    route: (route: HttpAPIRoute<Any, Any, Any>) => Promise<void>;
    view: (view: HttpViewRoute<Any, Any, Any>) => Promise<void>;
    use: (...middlewares: Any[]) => Promise<void>;
    interceptors: (...interceptors: Interceptor[] | Any[]) => Promise<void>;
    [x: string]: Any;
}
export declare type HttpCallable<Request, Response, Next> = {
    holder: Any;
    context: {
        http: {
            request: Request;
            response: Response;
            next: Next;
        };
        input: RequestRoute<Request, Response, Next>;
        behaviors?: ParameterContext<HttpParameter>[];
        caller: Any;
    };
};
export declare type RouteMetadata = {
    prefix: string;
    holder: Any;
    guards: GuardContext;
};
export declare type RouteActor = {
    uri?: string;
    record?: Any;
    guard?: GuardContextMetadata;
};
export declare type WebSocketActor = ObjectBehavior<RealtimeParameter> & RouteActor;
export declare type WebSocketRouteMetadata = RouteMetadata & {
    behaviors: ObjectMethodContext<RealtimeParameter[]>;
    transmitter: RealtimeTransmitter;
    actors: WebSocketActor[];
};
export declare type WebSocketBuilderMeta = {
    metas: WebSocketRouteMetadata;
};
export interface WebSocketAdapter<Server> extends Adapter<WebSocketBuilderMeta, Server>, Combinable<Any>, Listener<ServerOptions, void> {
    bind: (server: Any) => Promise<WebSocketAdapter<Server>>;
}
export interface GraphQLAdapter<T, Server> extends Adapter<T, Server>, Combinable<Any>, Listener<ServerOptions, void> {
    bind: (server: Any) => Promise<GraphQLAdapter<T, Server>>;
}
export interface TracingAdapter {
    create: (cfg?: TracingConfiguration) => Promise<void>;
    shutdown: () => Promise<void>;
}
