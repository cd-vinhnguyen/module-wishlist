"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwtResolver = exports.JwtResolverStatic = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("../errors");
const http_status_codes_1 = require("http-status-codes");
class JwtResolverStatic {
}
exports.JwtResolverStatic = JwtResolverStatic;
_a = JwtResolverStatic;
JwtResolverStatic.create = (args) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!JwtResolverStatic.$instance) {
        const jwt = yield Promise.resolve().then(() => tslib_1.__importStar(require('jsonwebtoken')));
        const { options } = args;
        _a.$instance = new JwtResolver(jwt, options);
    }
    return JwtResolverStatic.$instance;
});
class JwtResolver {
    constructor(_jwt, options) {
        this._jwt = _jwt;
        this.options = options;
        this.http = ['header', 'authorization'];
        this.ws = ['handshake', 'token'];
        this.resolve = (data) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _b;
            try {
                if (this._jwt && this.options) {
                    const { secret } = this.options.credentials;
                    return this._jwt.verify(data, secret, {
                        issuer: this.options.issuer,
                        algorithms: [this.options.alg]
                    });
                }
            }
            catch (error) {
                if (error instanceof Error)
                    throw new errors_1.APIError(http_status_codes_1.StatusCodes.UNAUTHORIZED, error.message);
            }
            throw new errors_1.APIError(http_status_codes_1.StatusCodes.UNAUTHORIZED, ((_b = this.options) === null || _b === void 0 ? void 0 : _b.message) || 'Invalid Token');
        });
    }
}
exports.JwtResolver = JwtResolver;
